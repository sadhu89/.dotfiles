trading?
canada_attribute?
self.valid?
exit
invoice
next
exit
invoice.invoice_date
cutover_date
exit
invoice
notification_type
exit
invoice
invoice.uid
invoice.file_identifier
next
exit
InvoiceNotification::TYPE[:canada_file_validation]
exit
retailer_hash
retailer_hash.values.compact
retailer_hash.values
retailer_hash.values.compact.empty?
retailer_hash.values.compact
[nil,2,nil].compact
["",2,""].compact
exit
next
retailer_hash.values
contact_hash[:retailer]
exit
ls
exit
invoice
invoice.uid
invoice.invoice_number
exit
order
order_hash
exit
continue
i
next
nex
next
Siegfried::Config.secrets[:logistics][:base_uri]
Siegfried::Config.secrets
Siegfried::Config.secrets.merge!(hi:"hola")
exit
Siegfried::Config.secrets
exit
Siegfried::Config.secrets.merge(settings)
Siegfried::Config.secrets.merge({hola:"hi"})
exit
continue
orders
exit
result
result.class
result.status
result.to_h
result
get('/api/v1/orders', query: { from_date: date })
get('/api/v1/orders', query: { from_date: date }).map(:&with_indifferent_access)
get('/api/v1/orders', query: { from_date: date }).to_a.map(:&with_indifferent_access)
JSON.parse(get('/api/v1/orders', query: { from_date: date })).map(:&with_indifferent_access)
result = get('/api/v1/orders', query: { from_date: date })
result
result.class
result.to_h
result.body
exit
result
exit
result
exit
result
exit
result
response
xit
exit
result
exit
result.code
exit
result.code
result.response
result.response.status
result.response.body
result.response.code
result.code
result
exit
result
result.body
result.map(:&with_indifferent_access)
result.body.map(:&with_indifferent_access)
result.body.map(&:with_indifferent_access)
result.map(&:with_indifferent_access)
exit
result.map(&:with_indifferent_access)
JSON.parse     "[{\"id\":1,\"name\":\"B000001234\",\"customer_ip\":\"10.236.136.209\",\"user_agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1)\",\"geoip_latitude\":\"123.456\",\"geoip_longitude\":\"-23.456\",\"geoip_region\":null,\"geoip_country_code\":\"AU\",\"locale\":\"en_AU\",\"use_shipping_details\":true,\"shipping_price_in_cents\":3980,\"currency_code\":\"AUD\",\"warehouse\":\"TO AU LM\",\"details\":\"Dolorem quos quia eveniet est laudantium nesciunt. Laborum reprehenderit veritatis explicabo fuga voluptatem. Cupiditate unde id qui animi corporis omnis alias. Adipisci illum esse quam nostrum autem non.\",\"created_at\":\"2015-04-15T05:45:46.279Z\",\"tax_code\":null,\"tax_name\":null,\"tax_percentage\":\"0.0\",\"freight_is_taxed\":false,\"price_includes_tax\":false,\"tax_in_cents\":0,\"sub_total_in_cents\":9997,\"grant_total_in_cents\":13977,\"shipping_method\":\"express\",\"shipping_name\":\"Express (2–8 days, tracking)\",\"saasu_invoice_uid\":1234567,\"saasu_file_identifier\":\"pty_ltd\",\"payment_method\":\"credit_card\",\"admin_url\":\"https://bellroy.com/admin/orders/1\",\"billing_customer\":{\"first_name\":\"Lauryn\",\"last_name\":\"Ziemann\",\"email\":\"jalyn_oberbrunner@email.com\",\"phone_number\":\"228.135.5846 x93714\"},\"billing_address\":{\"street_address_1\":\"1986 Raven Freeway\",\"street_address_2\":null,\"city\":\"Destroit\",\"state\":\"MI\",\"state_name\":\"Michigan\",\"postcode\":\"18585-8609\",\"country_name\":\"Sint Maarten\",\"country_code\":\"SX\"},\"shipping_customer\":{\"first_name\":\"Marcelle\",\"last_name\":\"Mueller\",\"email\":\"noel@email.com\",\"phone_number\":\"558.315.5658\"},\"shipping_address\":{\"street_address_1\":\"8269 Benton Extensions\",\"street_address_2\":null,\"state\":\"NH\",\"state_name\":\"New Hampshire\",\"city\":\"Valencia\",\"postcode\":\"09293\",\"country_name\":\"Venezuela\",\"country_code\":\"VE\"},\"order_line_items\":[{\"product_sku\":\"WETA-SLATE\",\"product_name\":\"Elements Travel\",\"quantity\":3,\"price_in_cents\":2190},{\"product_sku\":\"WTRA-MIDNIGHT\",\"product_name\":\"Travel Wallet\",\"quantity\":1,\"price_in_cents\":3427}]}]"
_
JSON.parse     ["{\"id\":1,\"name\":\"B000001234\",\"customer_ip\":\"10.236.136.209\",\"user_agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1)\",\"geoip_latitude\":\"123.456\",\"geoip_longitude\":\"-23.456\",\"geoip_region\":null,\"geoip_country_code\":\"AU\",\"locale\":\"en_AU\",\"use_shipping_details\":true,\"shipping_price_in_cents\":3980,\"currency_code\":\"AUD\",\"warehouse\":\"TO AU LM\",\"details\":\"Dolorem quos quia eveniet est laudantium nesciunt. Laborum reprehenderit veritatis explicabo fuga voluptatem. Cupiditate unde id qui animi corporis omnis alias. Adipisci illum esse quam nostrum autem non.\",\"created_at\":\"2015-04-15T05:45:46.279Z\",\"tax_code\":null,\"tax_name\":null,\"tax_percentage\":\"0.0\",\"freight_is_taxed\":false,\"price_includes_tax\":false,\"tax_in_cents\":0,\"sub_total_in_cents\":9997,\"grant_total_in_cents\":13977,\"shipping_method\":\"express\",\"shipping_name\":\"Express (2–8 days, tracking)\",\"saasu_invoice_uid\":1234567,\"saasu_file_identifier\":\"pty_ltd\",\"payment_method\":\"credit_card\",\"admin_url\":\"https://bellroy.com/admin/orders/1\",\"billing_customer\":{\"first_name\":\"Lauryn\",\"last_name\":\"Ziemann\",\"email\":\"jalyn_oberbrunner@email.com\",\"phone_number\":\"228.135.5846 x93714\"},\"billing_address\":{\"street_address_1\":\"1986 Raven Freeway\",\"street_address_2\":null,\"city\":\"Destroit\",\"state\":\"MI\",\"state_name\":\"Michigan\",\"postcode\":\"18585-8609\",\"country_name\":\"Sint Maarten\",\"country_code\":\"SX\"},\"shipping_customer\":{\"first_name\":\"Marcelle\",\"last_name\":\"Mueller\",\"email\":\"noel@email.com\",\"phone_number\":\"558.315.5658\"},\"shipping_address\":{\"street_address_1\":\"8269 Benton Extensions\",\"street_address_2\":null,\"state\":\"NH\",\"state_name\":\"New Hampshire\",\"city\":\"Valencia\",\"postcode\":\"09293\",\"country_name\":\"Venezuela\",\"country_code\":\"VE\"},\"order_line_items\":[{\"product_sku\":\"WETA-SLATE\",\"product_name\":\"Elements Travel\",\"quantity\":3,\"price_in_cents\":2190},{\"product_sku\":\"WTRA-MIDNIGHT\",\"product_name\":\"Travel Wallet\",\"quantity\":1,\"price_in_cents\":3427}]}"]
exit
result
result[0]
result[1]
result.body[0]
result.body[1]
result.body[2]
result.body[3]
result.to_a
JSON.parse(result)
JSON.parse(result)[0]
JSON.parse(result)[1]
JSON.parse(result)[1][:tax_name]
JSON.parse(result).map(&with_indifferent_access)
JSON.parse(result).map(&:with_indifferent_access)
JSON.parse(result).map(&:with_indifferent_access)[0][:tax_name]
JSON.parse(result).map(&:with_indifferent_access)[0][:warehouse]
result.map(&:with_indifferent_access)
[{ 'invoice_uid' => '1', 'invoice_number' => '2' }].to_json
result
http_result
http_result.code
http_result.body
http_result
http_result.class
http_result.parsed_response
http_result.parsed_response.class
http_result.to_h
http_result.body
http_result.body.class
JSON.parse(http_result.body)
orders = JSON.parse(http_result.body)
orders
orders.count
orders[0]
continue
http_result
http_result.code
http_result.error
http_result['error']
exit
orders
orders[0]
exit
orders
exit
order_numbers
exit
env.fetch('HTTP_AUTHORIZATION', '').split(' ', 2)
AppConfig.access.fetch('local_api', {})['token']
env
env.fetch('HTTP_AUTHORIZATION', '')
env
env.class
exit]
exit
canada_invalid_order?
invoice
next
continue
step
next
exit
step
next
exit
invoice
next
continue
next
exit
validator
validator.valid?
invoice
invoice.country_code
validator.valid?
validator.trading?
validator.send(:trading?)
validator.send(:exist_canada_attributes?)
validator.send(:exist_canada_attribute?)
validator.valid
validator.valid?
!validator.is_valid?
!validator.valid?
!validator.class
validator.class
validator.class.superclass
validator.instance_methods
validator.instance_method
validator.methods
invoice
invoice.valid?
!Landmark::CanadaOrderValidator.new(invoice).is_valid?
!Landmark::CanadaOrderValidator.new(invoice).valid?
next
continue
exit
verified?
exit
next
@activity
exit
invoice
next
exit
continue
next
step
next
nxml_for_invoice.to_xml
exit
self
shop_order
shop_order.billing_address
shop_order[:billing_address]
shop_order['billing_address']
shop_order.class
shop_order.country_code
exit
notification_types
next
notification
next
continue
InvoiceNotification.first
next
notification
notification_types
InvoiceNotification.wrong_saasu_file
InvoiceNotification.wrong_saasu_file?
InvoiceNotification.wrong_saasu_file
exit
continue
InvoiceNotification.wrong_file
InvoiceNotification.wrong_file_verification
next
notification
InvoiceNotification.where(notification_type:[:wrong_file])
InvoiceNotification.where(notification_type: :wrong_file)
InvoiceNotification.where(notification_type: 0)
InvoiceNotification.where(notification_type: 'wrong_file')
InvoiceNotification.where(notification_type: :wrong_file)
InvoiceNotification.where(notification_type: ['wrong_file'])
exit
order_number
@order_hash = Order.load(order_number).shop_order.body_hash
next
@order_hash.class
@order_hash.to_json
exit
next
order
order.to_json
order.class
exit
order
order.to_hash
exit
order.to_hash
order.to_hash.to_json
exit
notification_type
NOTIFICATION_TYPE
notification_types
NOTIFICATION_TYPES
notification_types.keys
notification_types.keys.first
notification_types.keys(0)
notification_types.keys[0]
notification_types.key(0)
exit
notification
continue
notification
InvoiceNotification.all
exit
Order.all
Order.new
Order.create(YAML.load("{\"id\":238,\"customer_ip\":\"59.167.123.145\",\"user_agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36\",\"geoip_latitude\":\"-37.8103\",\"geoip_longitude\":\"144.9544\",\"geoip_country_code\":\"AU\",\"geoip_region\":\"VIC\",\"locale\":\"en\",\"billing_customer_id\":250,\"shipping_customer_id\":null,\"use_shipping_details\":false,\"shipping_price_in_cents\":0,\"currency_id\":1,\"warehouse\":\"au_landmark\",\"details\":null,\"tax_code\":null,\"tax_name\":null,\"tax_percentage\":\"10.0\",\"freight_is_taxed\":true,\"price_includes_tax\":true,\"tax_in_cents\":0,\"cart_id\":3659549,\"created_at\":\"2016-07-25T01:46:59.201Z\",\"updated_at\":\"2016-07-25T01:46:59.206Z\",\"name\":\"B000000238\",\"shipping_method\":\"express\",\"shipping_name\":\"Express Post (1-3 days)\",\"include_tax_in_order\":false,\"billing_address_id\":1007,\"shipping_address_id\":null,\"max_shipping_date\":null,\"max_delivery_date\":null,\"saasu_file_identifier\":\"pty_ltd\"}"))
exit
Order.create(YAML.load("{\"id\":238,\"customer_ip\":\"59.167.123.145\",\"user_agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36\",\"geoip_latitude\":\"-37.8103\",\"geoip_longitude\":\"144.9544\",\"geoip_country_code\":\"AU\",\"geoip_region\":\"VIC\",\"locale\":\"en\",\"billing_customer_id\":250,\"shipping_customer_id\":null,\"use_shipping_details\":false,\"shipping_price_in_cents\":0,\"currency_id\":1,\"warehouse\":\"au_landmark\",\"details\":null,\"tax_code\":null,\"tax_name\":null,\"tax_percentage\":\"10.0\",\"freight_is_taxed\":true,\"price_includes_tax\":true,\"tax_in_cents\":0,\"cart_id\":3659549,\"created_at\":\"2016-07-25T01:46:59.201Z\",\"updated_at\":\"2016-07-25T01:46:59.206Z\",\"name\":\"B000000238\",\"shipping_method\":\"express\",\"shipping_name\":\"Express Post (1-3 days)\",\"include_tax_in_order\":false,\"billing_address_id\":1007,\"shipping_address_id\":null,\"max_shipping_date\":null,\"max_delivery_date\":null,\"saasu_file_identifier\":\"pty_ltd\"}"))
Order.create(YAML.load("{\"id\":238,\"customer_ip\":\"59.167.123.145\",\"user_agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36\",\"geoip_latitude\":\"-37.8103\",\"geoip_longitude\":\"144.9544\",\"geoip_country_code\":\"AU\",\"geoip_region\":\"VIC\",\"locale\":\"en\",\"billing_customer_id\":250,\"shipping_customer_id\":null,\"use_shipping_details\":false,\"shipping_price_in_cents\":0,\"currency_id\":1,\"warehouse\":\"au_landmark\",\"details\":null,\"tax_code\":null,\"tax_name\":null,\"tax_percentage\":\"10.0\",\"freight_is_taxed\":true,\"price_includes_tax\":true,\"tax_in_cents\":0,\"cart_id\":3659549,\"created_at\":\"2016-07-25T01:46:59.201Z\",\"updated_at\":\"2016-07-25T01:46:59.206Z\",\"name\":\"B000000238\",\"shipping_method\":\"express\",\"shipping_name\":\"Express Post (1-3 days)\",\"include_tax_in_order\":false,\"billing_address_id\":1007,\"shipping_address_id\":null,\"max_delivery_date\":null,\"saasu_file_identifier\":\"pty_ltd\"}"))
Order.create(YAML.load("{\"id\":238,\"customer_ip\":\"59.167.123.145\",\"user_agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36\",\"geoip_latitude\":\"-37.8103\",\"geoip_longitude\":\"144.9544\",\"geoip_country_code\":\"AU\",\"geoip_region\":\"VIC\",\"locale\":\"en\",\"billing_customer_id\":250,\"shipping_customer_id\":null,\"use_shipping_details\":false,\"shipping_price_in_cents\":0,\"currency_id\":1,\"warehouse\":\"au_landmark\",\"details\":null,\"tax_code\":null,\"tax_name\":null,\"tax_percentage\":\"10.0\",\"freight_is_taxed\":true,\"price_includes_tax\":true,\"tax_in_cents\":0,\"cart_id\":3659549,\"created_at\":\"2016-07-25T01:46:59.201Z\",\"updated_at\":\"2016-07-25T01:46:59.206Z\",\"name\":\"B000000238\",\"shipping_method\":\"express\",\"shipping_name\":\"Express Post (1-3 days)\",\"include_tax_in_order\":false,\"billing_address_id\":1007,\"shipping_address_id\":null,\"saasu_file_identifier\":\"pty_ltd\"}"))
Order.all
Order.new
Order.create(YAML.load("{\"id\":238,\"customer_ip\":\"59.167.123.145\",\"user_agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36\",\"geoip_latitude\":\"-37.8103\",\"geoip_longitude\":\"144.9544\",\"geoip_country_code\":\"AU\",\"geoip_region\":\"VIC\",\"locale\":\"en\",\"billing_customer_id\":250,\"shipping_customer_id\":null,\"use_shipping_details\":false,\"shipping_price_in_cents\":0,\"currency_id\":1,\"warehouse\":\"au_landmark\",\"details\":null,\"tax_code\":null,\"tax_name\":null,\"tax_percentage\":\"10.0\",\"freight_is_taxed\":true,\"price_includes_tax\":true,\"tax_in_cents\":0,\"cart_id\":3659549,\"created_at\":\"2016-07-25T01:46:59.201Z\",\"updated_at\":\"2016-07-25T01:46:59.206Z\",\"name\":\"B000000238\",\"shipping_method\":\"express\",\"shipping_name\":\"Express Post (1-3 days)\",\"include_tax_in_order\":false,\"billing_address_id\":1007,\"shipping_address_id\":null,\"max_shipping_date\":null,\"max_delivery_date\":null,\"saasu_file_identifier\":\"pty_ltd\"}"))
Order.create(YAML.load("{\"id\":238,\"customer_ip\":\"59.167.123.145\",\"user_agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36\",\"geoip_latitude\":\"-37.8103\",\"geoip_longitude\":\"144.9544\",\"geoip_country_code\":\"AU\",\"geoip_region\":\"VIC\",\"locale\":\"en\",\"billing_customer_id\":250,\"shipping_customer_id\":null,\"use_shipping_details\":false,\"shipping_price_in_cents\":0,\"currency_id\":1,\"warehouse\":\"au_landmark\",\"details\":null,\"tax_code\":null,\"tax_name\":null,\"tax_percentage\":\"10.0\",\"freight_is_taxed\":true,\"price_includes_tax\":true,\"tax_in_cents\":0,\"cart_id\":3659549,\"created_at\":\"2016-07-25T01:46:59.201Z\",\"updated_at\":\"2016-07-25T01:46:59.206Z\",\"name\":\"B000000238\",\"shipping_method\":\"express\",\"shipping_name\":\"Express Post (1-3 days)\",\"include_tax_in_order\":false,\"billing_address_id\":1007,\"shipping_address_id\":null,\"saasu_file_identifier\":\"pty_ltd\"}"))
exit
invoice
Views::V1::Invoice
Views::V1::FinancialInvoice.count
exit
Views::V1::FinancialInvoice.count
Views::V1::FinancialInvoiceLine.count
Transformed::Financials::Invoice
Transformed::Financials::Invoice.count
exit
Views::V1::FinancialInvoiceLine.count
Views::V1::FinancialInvoiceLine.where(source_identifier: '113695357')
Views::V1::FinancialInvoiceLine.where(source_identifier: '113695357').invoice
Views::V1::FinancialInvoiceLine.where(source_identifier: '113695357').financial_invoice
Views::V1::FinancialInvoiceLine.where(source_identifier: '113695357')
Views::V1::FinancialInvoiceLine.where(source_identifier: '113695357').invoice
Views::V1::FinancialInvoiceLine.where(source_identifier: '113695357').financial_invoice
Views::V1::FinancialInvoice.where(source_identifier: '113695357')
Views::V1::FinancialInvoice.where(source_identifier: '77978349')
Views::V1::FinancialInvoice.where(source_identifier: '77978349').financial_invoices
Views::V1::FinancialInvoice.where(source_identifier: '77978349').first.financial_invoices
Views::V1::FinancialInvoiceLine.where(source_identifier: '113695357').first.financial_invoice
Views::V1::FinancialInvoiceLine.find_by(source_identifier: '113695357').financial_invoice
file_path
"Bellroy-NordstromCanada-POS_03032016-151634.json131015104046957121.json".split('-',2)
"Bellroy-NordstromCanada-POS_03032016-151634.json131015104046957121.json".split('-',3)
"Bellroy-NordstromCanada-POS_03032016-151634.json131015104046957121.json".split('-',3)[]1
"Bellroy-NordstromCanada-POS_03032016-151634.json131015104046957121.json".split('-',3)[1]
path = "/tmp/srv/sftp/b2bgateway/bellroy/progress/Bellroy-NordstromCanada-POS_03032016-151634.json131015104046957121.json"
path
File.read(file_path)
File.read(file_path).methods
File.basename(file_path)
File.basename(file_path).split('-')(3)[1]
File.basename(file_path).split('-')(3exit
exit
merged_shop_orders
exit
shop_orders
next
merged_shop_orders
exit
merged_shop_orders
merged_shop_orders[0]
shop_orders[0]
merged_shop_orders[0]["not_before_after"]
merged_shop_orders[0]["not_before_date"]
merged_shop_orders.first["not_before_date"]
exit
next
shop_orders
next
continue
n
exit
shop_orders
shop_orders.first
n
exit
n
exit
n
source
n
exit
n
source
n
exit
EdiNordstromPurchaseOrder.create!(purchase_order_number: purchase_order_number,
  dont_ship_before_date: dont_ship_before_date,
  dont_ship_after_date: dont_ship_after_date,
source: source)
exit
file_path
n
step
n
source
n
exit
source
SOURCES[source]
exit
SOURCES[source][:country_code]
exit
nordstrom_prices
nordstrom_prices.merge({"lo"=>{"cad"=>32423}})
a = nordstrom_prices.merge({"lo"=>{"cad"=>32423}})
a
product
a = product.prices.merge({"lo"=>{"cad"=>32423}})
a = product.prices.merge!({"lo"=>{"cad"=>32423}})
a = product.prices
exit
nordstrom_prices
product
exit
nordstrom_prices
exit
product
product.class
product
Bellroy::Product.find_variant("WHSD-COCOA")
exit
@app
@request
env
app
exit
env
env['REQUEST_URI']
env[:REQUEST_URI]
exit
continue
env['REQUEST_URI']
env['REQUEST_URI'] == '/sadhu'
env['REQUEST_URI'] = '/our-story'
exit
@app
env
exit
a = @app.call(env)
exit
env
uri = env["REQUEST_URI"]
parsed_uri = URI.parse(uri)
parsed_uri
parsed_uri.host
parsed_uri.path
parsed_uri.methods
parsed_uri.query
test = URI.parse('/hola?a=2')
test.query
parsed_uri
uri
uri = env['REQUEST_URI']
'Hola&mundo'.sub('&','?')
exit
new_uri
new_uri.sub('%23\w*', '')
new_uri.sub(/%23\w*/, '')
new_uri =~ /%23(\w*)/
Regexp.last_match(0)
Regexp.last_match(1)
new_uri.sub('%23\w*', '') + '#' + Regexp.last_match(0)
new_uri.sub('%23\w*', '')
new_uri.sub('%23\w*', '') + '#' + Regexp.last_match(0)
new_uri.sub('%23\w*', '') + "#" + Regexp.last_match(0)
new_uri.sub('%23\w*', '')exit + "#" + Regexp.last_match(0)
exit
(new_uri.sub(/%23\w*/, '') + '#' + Regexp.last_match(1))
new_uri.sub(/%23\w*/, '')
Regexp.last_match(1)
Regexp.last_match(0)
Regexp.last_match(1)
$1
new_uri =~ /%23(\w*)/i
Regexp.last_match(1)
exit
Regexp.last_match(1)
continue
env
req = make_request(env)
req
env
req
req.env
env
req
req.body
req.body.t_S
req.body.to_S
req.body.to_s
exit
env
exit
env
/home/sadhu/Projects/bellroy/spec/lib/wrong_url_handler_spec.rb
exit
prices = product.variant.prices
exit
product.variant.prices
exit
product
product.variant.prices
exit
product.variant.prices
exit
currency
n
prices
product.variant.prices
exit
continue
exit
uri
parsed_uri = URI::parse(uri)
parsed_uri
parsed_uri.fragment
uri = "/pages/customer-care#hola_mundo&gclid=CPi2tYHHvc0CFYaWvAodYPgBlw"
uti
uri
parsed_uri = URI::parse(uri)
parsed_uri.fragment
parsed_uri.fragment = "hola"
parsed_uri.fragment
parsed_uri
parsed_uri.to_s
/^[^?]*&gclid/i =~ parsed_uri
/^[^?]*&gclid/i =~ parsed_uri.to_S
/^[^?]*&gclid/i =~ parsed_uri.to_s
/^[^?]*&gclid/i =~ parsed_uri
parsed_uri-path
parsed_uri.path
parsed_uri.methods
uri.fragment
parsed_uri.fragment
parsed_uri.fragment.include("la")}
parsed_uri.fragment.include("la")
parsed_uri.fragment.includes("la")
parsed_uri.fragment.include("la")
parsed_uri.fragment.contents("la")
parsed_uri.fragment.content("la")
parsed_uri.fragment.to_s.contents("la")
parsed_uri.fragment.class
parsed_uri.fragment.include?("la")
parsed_uri
parsed_uri.query="chau"
parsed_uri
parsed_uri.query="saludo=hi"
parsed_uri
URI.decode_www_form(uri)
uri
a = URI.decode_www_form(uri)
URI.encode_www_form a
a = URI.decode_www_form("/pages/customer-care#hola_mundo?gclid=CPi2tYHHvc0CFYaWvAodYPgBlw")
ary = URI.decode_www_form(“a=1&a=2&b=3”)
ary = URI.decode_www_form("a=1&a=2&b=3")
ary = URI.decode_www_form("&a=1&a=2&b=3")
ary = URI.decode_www_form("google.com&a=1&a=2&b=3")
ary = URI.decode_www_form("google.com?a=1&a=2&b=3")
uri
uri.fragment.split('&gclid=').first
uri
URI.split(env['PATH_INFO'])
new_uri
URI.parse(new_uri)
exit
new_uri
parsed_uri = URI.parse(new_uri)
parsed_uri.split
URI.split(new_uri)
exit
uri
continue
exit
uri = env['PATH_INFO']
URI.parse(uri)
parsed_uri = URI.parse(uri)
URI.split(uri)
env['PATH_INFO']
env['REQUEST_URI']
env['REQUESTED_URI']
env['REQUEST_URI']
uri
requested_uri
env['REQUEST_URI'] 
env['REQUEST_URI']
env
exit
env
exit
env
env["ORIGINAL_FULLPATH"]
env["SCRIPT_NAME"]
env["HEADERS"]
env["QUERY_STRING"]
env["HTTP_HOST"]
env["URL_PATTERN"]
env.select{|k,v| v.include?'localhost'}
env.to_h.select{|k,v| v.include?'localhost'}
env.to_h
env.to_h.map{|k,v| v.include?'localhost'}
env.to_h.map{|k,v| v.include?'localhost
env
env['TARNSFORMATION']
env['TRANSFORMATION']
env['ORIGINAL_FULLPATH']
env['FULLPATH']
env.each{|e| p e}
env.cont
env.length
env.seleect{|k,v| v.include? 'localhost'}
env.select{|k,v| v.include? 'localhost'}
env.select{|k,v| p v}
env.select{|k,v| v=~'localhost'}
env.select{|k,v| v=~/localhost/}
env.select{|k,v| v=~/delivery/}
uri
env['ORIGINAL_FULLPATH']
env.select{|k,v| v=~/customer/}
exit
new_uri
new_uri.fragment
new_uri.fragment.include?('&gclid=')
new_uri.fragment.to_s.include?('&gclid=')
new_uri.fragment.to_s.include?('&gclid')
new_uri.fragment.to_s.include?('gclid')
new_uri.fragment.to_s.include?('gclid=')
new_uri.fragment.to_s.include?('&gclid=')
new_uri.fragment.to_s.include?('?gclid=')
exit
new_uri
new_uri.fragment
new_uri.fragment.include?('?gclid=')
new_uri.fragment, gclid_value = new_uri.fragment.split('?gclid=')
gclid_value
new_query_args = URI.decode_www_form(new_uri.query)
new_uri.query
exit
URI.unescape(uri.sub('&', '?'))
URI.unescape(uri.sub('&', '?')).query
exit
env['PATH_INFO']
env
exit
EDI::MergedShopOrder
EDI::MergedShopOrder.new
n
q
n
exit
load_shop_orders
load_shop_order
load_shop_orders(file_path)
exit
n
source
step
ShopOrdersMerger
n
shop_orders
n
mso
mso.shop_orders
exit
products
price
prices
style
exit
product.variant
product.variant.prices
exit
product
prices
n
prices
products[0]
products[0].variant.prices
prices
products[0].formatted_price
products[0].price_in_cents
products[0].nordstrom_price_in_cents('cad')
products[0].variant.nordstrom_price_in_cents('cad')
products[0].variant.prices
products[0].prices
self..prices
self.prices
exit
shop_orders
n
exit
n
exit
n
s
n
e
n
e
exit
step
n
alt
alt.name
alt.name = "Z"
alt
n
continue
exit
@high_value_job
n
exit
args
step
next
n
@high_value_job
class Foo
  @class_var = :foo
  def self.foo
    puts @class_var
  end
end
class Bar < Foo
  @class_var = :bar
end
Foo.foo
Bar.foo
class Foo
  @class_var = :foo
  def self.foo
    puts @class_var
  end
end
class Bar < Foo
end
Foo.foo
Bar.foo
page
page.images
page.browser
exit
current_url
exit
visit('/')
ENV
REQUEST_URI
exit
params
params["accesslint"]
params["accesslint"]["violations"]
warnings
warnings[0]
warnings[0].strip
warnings[0].strip[1..-1]
warnings[1].strip
warnings[2].strip
warnings[3].strip[0..-2]
exit
n
exit
warnings
formatted_warnings
exit
formatted_warnings
exit
formatted_warnings
exit
formatted_warnings
exit
warnings.split("\n").split('|')
warnings.split("\n")
warnings.split("\n").count
warnings.split("\n").collapse.count
warnings.split("\n").compact.count
warnings.split("\n").first
warnings.split("\n").last
warnings.split("\n")[1]
warnings.split("\n").reject("")
warnings.split("\n").reject{|warning| warning == ""}
warnings.split("\n").reject{|warning| warning == ""}.cont
warnings.split("\n").reject{|warning| warning == ""}.cotnt
warnings.split("\n").reject{|warning| warning == ""}.count
n
AccesslintHelper.warnings_count(:moderate)
metrics_hash
n
exit
metrics_params
exit
metrics_hash
n
exit
metrics_hash
exit
issues_hash
AccesslintHelper.groupped_warnings
AccesslintHelper.groupped_warnings["moderate"]
exit
app.contact_us_path
app.contact_path
exit
Rails.application.routes.routes
5~6~6~current_routes = Rails.application.routes.routes.map do |route|
route.path.spec.to_s
current_routes = Rails.application.routes.routes.map do |route|
  route.path.spec.to_s
current_routes = Rails.application.routes.routes.map do |route|
  route.path.spec.to_s
end
exit
"leather_rfid".humanize
exit
q
s
sssss
a
q
exit
a
a.count
a.first
a.firsa[1]
[1]
a[1]
a[2]
a[3]
a
available_colors
a
n
a
a.first.class
a.first
a.map(&:identifier)
a
a.map{|e| e[:identifier]}
a.order_by{|e| e[:variant].material_label}.map{|e| e[:identifier]}
[3,2,1].order
[3,2,1].order_by
[3,2,1].sort
a.sort_by{|e| e[:variant].material_label}.map{|e| e[:identifier]}
a.sort_by{|e| e[:variant].material}.map{|e| e[:identifier]}
a.sort_by{|e| e[:variant].material_label}.map{|e| e[:identifier]}
exit
continue
info
info.count
n
continue
info.count
info.flatten.compact.uniq { |color| color[:swatch_and_color] }.sort_by{|e| e[:variant].material_label}
info.flatten.compact.uniq { |color| color[:swatch_and_color] }.sort_by{|e| e[:variant].material_label}.count
info
info == info.flatten
info.diff info.flatten
info.flatten.count
info.flatten.uniq
info.flatten.uniq.count
color
exit
puts \x52\x75\x62\x79\x46\x75
puts "\x52\x75\x62\x79\x46\x75"
exit
p \x52\x75\x62\x79\x46\x75
\x52\x75\x62\x79\x46\x75
"\x52\x75\x62\x79\x46\x75"
"RubyFu".to_a
"RubyFu".split
"RubyFu".split("")
["R", "u", "b", "y", "F", "u"].join
["1", "2", "3", "4"].sum
["1", "2", "3", "4"].map(&:to_i).sum
["1", "2", "3", "4"].map(&:to_i)
["1", "2", "3", "4"].map(&:to_i).sum
exit
Retailer.count
Retailer.delete_all
Retailer.count
exit
achievement_params
exit
achievement_params
exit
Retailer.count
Tag.count
Tagging.count
Tagdging.count
Tagging.count
exit
n
nn
n
exit
links.first
exit
links
document
uri
body
uri
body
uri  = URI("http://www.bellroy.com")
body = Net::HTTP.get(uri)
uri  = URI("http://www.bellroy.com")uri  = URI("http://bellroy.com/products?filter=all")
body = Net::HTTP.get(uri)
uri  = URI("http://bellroy.com/products?filter=all")
body = Net::HTTP.get(uri)
uri  = URI("http://www.denverpost.com")
body = Net::HTTP.get(uri)
uri  = URI("http://www.denverpost.com/frontpage")
body = Net::HTTP.get(uri)
uri  = URI("http://www.denverpost.com/front-pages/")
body = Net::HTTP.get(uri)
exit
links
links.first
exit
links.first
link = links.first
ls link
ls -v link
ls --help
ls -v link
link
link[:href]
link.css
link.css('href')
link
link.children
link.children.first
DeployNotifier.singleton.notify_succeeded
ENV['HOME']
File.join(ENV['HOME'], '.slack_api_key')
def get_slack_api_token
  File.read(File.join(ENV['HOME'], '.slack_api_key'))
end
token = get_slack_api_token
payload = {
  body:  {
    token: token,
    channel: DEV_ANNOUNCE_CHANNEL_ID,
    ts: Time.now,
    text: 'hola'
  }
}
response = HTTParty.post('https://slack.com/api/chat.update', payload)
def get_slack_api_token
  File.read(File.join(ENV['HOME'], '.slack_api_key'))
end
token = get_slack_api_token
payload = {
  body:  {
    token: token,
    channel: 'C0421D7R9',
    ts: Time.now,
    text: 'hola'
  }
}
response = HTTParty.post('https://slack.com/api/chat.update', payload)
def get_slack_api_token
  File.read(File.join(ENV['HOME'], '.slack_api_key'))
end
token = get_slack_api_token
payload = {
  body:  {
    token: "xoxp-4069449787-30948113633-76499359268-554c4e1138",
    channel: 'C0421D7R9',
    ts: Time.now,
    text: 'hola'
  }
}
response = HTTParty.post('https://slack.com/api/chat.update', payload)
def get_slack_api_token
  File.read(File.join(ENV['HOME'], '.slack_api_key'))
end
token = get_slack_api_token
payload = {
  body:  {
    token: "xoxp-4069449787-30948113633-76499359268-554c4e1138",
    channel: 'C0421D7R9',
    as_user: true,
    text: 'hola'
  }
}
response = HTTParty.post('https://slack.com/api/chat.update', payload)
def get_slack_api_token
  File.read(File.join(ENV['HOME'], '.slack_api_key'))
end
token = get_slack_api_token
payload = {
  body:  {
    token: "xoxp-4069449787-30948113633-76499359268-554c4e1138",
    channel: 'C0421D7R9',
    as_user: true,
    text: 'hola'
  }
}
response = HTTParty.post('https://slack.com/api/chat.postMessage', payload)
def get_slack_api_token
  File.read(File.join(ENV['HOME'], '.slack_api_key'))
end
token = get_slack_api_token
payload = {
  body:  {
    token: token,
    channel: 'C0421D7R9',
    as_user: true,
    text: 'hola'
  }
}
response = HTTParty.post('https://slack.com/api/chat.postMessage', payload)
token = get_slack_api_token
def get_slack_api_token
  File.read(File.join(ENV['HOME'], '.slack_api_key'))
end
token = get_slack_api_token
payload = {
  body:  {
    token: token,
    channel: 'C0421D7R9',
    as_user: true,
    text: 'hola'
  }
}
def get_slack_api_token
  File.read(File.join(ENV['HOME'], '.slack_api_key'))
end
token = get_slack_api_token
payload = {
  body:  {
    token: token,
    channel: 'C0421D7R9',
    as_user: false,
    text: 'test'
  }
}
response = HTTParty.post('https://slack.com/api/chat.postMessage', payload)
exit
browser = Capybara.current_session
url = 'https://github.com/jnicklas/capybara'
browser.visit url
browser.save_and_open_page
browser.save_and_open_screenshot
ls -v browser
ls browser
ls -v browser
browser.current_url
links = browser.all 'li a'
links.count
links.last
links.first
ls links.first
ls -v links.first
links.first.text
links.first.value
links.first
p links.first
links.first['href']
links.first.click
browser.current_url
links.first.click_link
browser.go_back
links.first.click_link
browser.current_url
links = browser.all 'li a'
links.first.click_link
browser.all 'li a'
browser.all('li a').class
browser.all('li a').class.ancestors
browser.all('li a').each{ |a| puts a.text, " #{a['href']}", ""}
visit 'http://bellroy.com/sitemap.xml'
visit 'http://bellroy.com/sitemap'
browser.visit 'http://bellroy.com/sitemap'
browser.save_and_open_page
browser.visit 'http://bellroy.com/sitemap.xml'
browser.save_and_open_page
browser.visit 'bellroy.com/sitemap'
browser.visit 'www.bellroy.com/sitemap'
browser.visit 'wwww.bellroy.com/sitemap'
browser.visit 'hhtps://bellroy.com/sitemap'
browser.visit 'https://bellroy.com/sitemap'
browser.visit 'http://bellroy.com/sitemap'
browser.all 'url loc'
links = browser.all 'url loc'
links.first
links.first.text
links.first.value
links.last.value
links.last.text
links[4].text
links[4]['href']
p links[4]
puts links[4]
inspect links[4]
puts links[4].inspect
Nokogiri
Nokogiri::HTML
Nokogiri::XML
xml_doc  = Nokogiri::XML("<root><aliens><alien><name>Alf</name></alien></aliens></root>")
browser.page
ls browser
browser.body
Nokogiri::XML(browser.body)
Nokogiri::XML(browser.body).css("url loc")
Nokogiri::XML(browser.body).css("url loc").first
Nokogiri::XML(browser.body).css("url loc").map(&:text)
Nokogiri::XML(browser.body).css("url loc").map(&:text).select{|url| url=~/wallets/}
Nokogiri::XML(browser.body).css("url loc").map(&:text)
Nokogiri::XML(browser.body).css("url loc").map(&:text).select{|url| url=~/products/}
Nokogiri::XML(browser.body).css("url loc").map(&:text).select{|url| url=~/products\//}
def format_price(url, size, price)
  "url:#{url} size:#{size || 'Default'}, price:#{price}"
end
browser = Capybara.current_session
browser.visit 'http://bellroy.com/sitemap.xml'
urls = Nokogiri::XML(browser.body).css("url loc").map(&:text).select{|url| url=~/products\//}
prices = []
urls.each do |url|
  browser.visit url
  browser.all('product-color-selector-title').each do |price|
    prices << format_price(url, nil, price.text)
  end
end
urls = ['http://bellroy.com/products/note-sleeve-wallet']
prices = []
urls.each do |url|
  browser.visit url
  browser.all('product-color-selector-title').each do |price|
    prices << format_price(url, nil, price.text)
  end
end
broser.current_url
browser.current_url
browser.all('product-color-selector-title')
browser.css('product-color-selector-title')
browser.all('.product-color-selector-title')
urls = ['http://bellroy.com/products/note-sleeve-wallet']
prices = []
urls.each do |url|
  browser.visit url
  browser.all('.product-color-selector-title').each do |price|
    prices << format_price(url, nil, price.text)
  end
end
browser.all('.product-color-selector-title')
browser.all('.product-color-selector-title').first
browser.all('.product-color-selector-title').first.text
urls = ['http://bellroy.com/products/note-sleeve-wallet']
prices = []
urls.each do |url|
  browser.visit url
  browser.all('.product-color-selector-title').each do |price|
    prices << format_price(url, nil, price.text)
  end
end
prices
urls.each do |url|
  browser.visit url
  browser.all('.product-color-selector-title').each do |price|
    prices << format_price(url, nil, price.text.split('-').last.strip)
  end
end
prices
browser.all('.product-color-selector-title').first.text
browser.all('.product-color-selector-title').first.text.split('-')
browser.all('.product-color-selector-title').first.text.split('—')
browser.all('.product-color-selector-title').first.text.split('—').last
urls = ['http://bellroy.com/products/note-sleeve-wallet']
prices = []
urls.each do |url|
  browser.visit url
  browser.all('.product-color-selector-title').each do |price|
    prices << format_price(url, nil, price.text.split('—').last.strip)
  end
end
prices
browser.visit 'http://bellroy.com/products/all-conditions-phone-pocket/leather_standard/black'
browser.visit 'http://bellroy.com/products/all-conditions-phone-pocket/
'
browser.visit 'http://bellroy.com/products/all-conditions-phone-pocket'
browser.all('option')
browser.all('option').count
browser.all('#size_select option').count
select('Standard', from: 'Select Size')
browser.select('Standard', from: 'Select Size')
browser.select('Standard')
browser.select('Standard')browser.all('option')
browser.all('option')
browser.all('option').first.text
[] || 3
a ||= 3
a ||= []
b ||= []
b||=5
def format_price(url, size, price)
  "url:#{url} size:#{size}, price:#{price}"
end
browser = Capybara.current_session
browser.visit 'http://bellroy.com/sitemap.xml'
#urls = Nokogiri::XML(browser.body).css("url loc").map(&:text).select{|url| url=~/products\//}
urls = ['http://bellroy.com/products/all-conditions-phone-pocket']
prices = []
urls.each do |url|
  browser.visit url
  options = browser.all('option').map(&:text)
  options << 'Default' if options.empty?
  options.each do |option|
    select option if option!= 'Default'
    browser.all('.product-color-selector-title').each do |price|
      prices << format_price(url, nil, price.text.split('—').last.strip)
    end
  end
  prices
def format_price(url, size, price)
  "url:#{url} size:#{size}, price:#{price}"
end
browser = Capybara.current_session
browser.visit 'http://bellroy.com/sitemap.xml'
#urls = Nokogiri::XML(browser.body).css("url loc").map(&:text).select{|url| url=~/products\//}
urls = ['http://bellroy.com/products/all-conditions-phone-pocket']
prices = []
urls.each do |url|
  browser.visit url
  options = browser.all('option').map(&:text)
  options << 'Default' if options.empty?
  options.each do |option|
    select option if option!= 'Default'
    browser.all('.product-color-selector-title').each do |price|
      prices << format_price(url, option, price.text.split('—').last.strip)
    end
  end
end
def format_price(url, size, price)
  "url:#{url} size:#{size}, price:#{price}"
end
browser = Capybara.current_session
browser.visit 'http://bellroy.com/sitemap.xml'
def format_price(url, size, price)
  "url:#{url} size:#{size}, price:#{price}"
end
browser = Capybara.current_session
browser.visit 'http://bellroy.com/sitemap.xml'
#urls = Nokogiri::XML(browser.body).css("url loc").map(&:text).select{|url| url=~/products\//}
urls = ['http://bellroy.com/products/all-conditions-phone-pocket']
prices = []
urls.each do |url|
  browser.visit url
  options = browser.all('option').map(&:text)
  options << 'Default' if options.empty?
  options.each do |option|
    select option if option!= 'Default'
    browser.all('.product-color-selector-title').each do |price|
      prices << format_price(url, option, price.text.split('—').last.strip)
    end
  end
end
urls = ['http://bellroy.com/products/all-conditions-phone-pocket']
prices = []
urls.each do |url|
  browser.visit url
  options = browser.all('option').map(&:text)
  options << 'Default' if options.empty?
  options.each do |option|
    browser.select option if option!= 'Default'
    browser.all('.product-color-selector-title').each do |price|
      prices << format_price(url, option, price.text.split('—').last.strip)
    end
  end
end
prices
exit
def format_price(url, size, price)
  "url:#{url} size:#{size}, price:#{price}"
end
browser = Capybara.current_session
browser.visit 'http://bellroy.com/sitemap.xml'
#urls = Nokogiri::XML(browser.body).css("url loc").map(&:text).select{|url| url=~/products\//}
urls = ['http://bellroy.com/products/all-conditions-phone-pocket']
prices = []
urls.each do |url|
  browser.visit url
  options = browser.all('option').map(&:text)
  options << 'Default' if options.empty?
  options.each do |option|
    browser.select option if option!= 'Default'
    browser.all('.product-color-selector-title').each do |price|
      prices << format_price(url, option, price.text.split('—').last.strip)
    end
  end
end
File.open('prices.txt', 'w+') { |f| f.puts(prices) }
def format_price(url, size, price)
  "url:#{url} size:#{size}, price:#{price}"
end
browser = Capybara.current_session
browser.visit 'http://bellroy.com/sitemap.xml'
#urls = Nokogiri::XML(browser.body).css("url loc").map(&:text).select{|url| url=~/products\//}
urls = ['http://bellroy.com/products/all-conditions-phone-pocket']
prices = []
urls.each do |url|
  browser.visit url
  options = browser.all('option').map(&:text)
  options << 'Default' if options.empty?
  options.each do |option|
    browser.select option if option!= 'Default'
    browser.all('.product-color-selector-title').each do |price|
      prices << format_price(url, option, price.text.split('—').last.strip)
    end
  end
end
require_relative 'setup_capybara'
def format_price(url, size, price)
  "url:#{url} size:#{size}, price:#{price}"
end
browser = Capybara.current_session
browser.visit 'http://bellroy.com/sitemap.xml'
#urls = Nokogiri::XML(browser.body).css("url loc").map(&:text).select{|url| url=~/products\//}
urls = ['http://bellroy.com/products/all-conditions-phone-pocket']
prices = []
urls.each do |url|
  browser.visit url
  options = browser.all('option').map(&:text)
  options << 'Default' if options.empty?
  options.each do |option|
    browser.select option if option!= 'Default'
    browser.all('.product-color-selector-title').each do |price|
      prices << format_price(url, option, price.text.split('—').last.strip)
    end
  end
end
browser = Capybara.current_session
browser.visit 'http://bellroy.com/sitemap.xml'require_relative 'setup_capybara'
require_relative 'setup_capybara'
browser = Capybara.current_session
browser.visit 'http://bellroy.com/sitemap.xml'
urls = ['http://bellroy.com/products/note-sleeve-wallet']
browser.visit urls.first
browser.visit 'bellroy.com'
browser.visit 'http://bellroy.com'
browser.visit 'http://bellroy.com/products'
exit
browser = Capybara.current_session
browser.visit 'http://bellroy.com/sitemap.xml'
urls = Nokogiri::XML(browser.body).css("url loc").map(&:text).select{|url| url=~/products\//}
browser = Capybara.current_session
browser.visit 'http://bellroy.com/sitemap.xml'
urls = Nokogiri::XML(browser.body).css("url loc").map(&:text).select{|url| url=~/products\//}
require_relative 'setup_capybara'
browser = Capybara.current_session
browser.visit 'http://bellroy.com/sitemap.xml'
urls = Nokogiri::XML(browser.body).css("url loc").map(&:text).select{|url| url=~/products\//}
browser.visit 'http://bellroy.com/products/card-sleeve-wallet'
browser.find('.price').text
urls = ['http://bellroy.com/products/card-sleeve-wallet']
prices = []
urls.each do |url|
  browser.visit url
  options = browser.all('option').map(&:text)
  options << 'Default' if options.empty?
  options.each do |option|
    browser.select option if option!= 'Default'
    prices = browser.all('.product-color-selector-title').map(:&text).map{ |price| price.split('-').strip }
    prices << browser.find('.price').text if prices.empty?
    prices.each do |price|
      prices << format_price(url, option, price)
    end
  end
end
urls = ['http://bellroy.com/products/card-sleeve-wallet']
prices = []
urls.each do |url|
  browser.visit url
  options = browser.all('option').map(&:text)
  options << 'Default' if options.empty?
  options.each do |option|
    browser.select option if option!= 'Default'
    prices = browser.all('.product-color-selector-title').map(&:text).map{ |price| price.split('-').strip }
    prices << browser.find('.price').text if prices.empty?
    prices.each do |price|
      prices << format_price(url, option, price)
    end
  end
end
def format_price(url, size, price)
  "url:#{url}, size:#{size}, price:#{price}"
end
urls = ['http://bellroy.com/products/card-sleeve-wallet']
prices = []
urls.each do |url|
  browser.visit url
  options = browser.all('option').map(&:text)
  options << 'Default' if options.empty?
  options.each do |option|
    browser.select option if option!= 'Default'
    prices = browser.all('.product-color-selector-title').map(&:text).map{ |price| price.split('-').strip }
    prices << browser.find('.price').text if prices.empty?
    prices.each do |price|
      prices << format_price(url, option, price)
    end
  end
end
require_relative 'setup_capybara'
def format_price(url, size, price)
  "url:#{url}, size:#{size}, price:#{price}"
end
require_relative 'setup_capybara'
def format_price(url, size, price)
  "url:#{url}, size:#{size}, price:#{price}"
end
browser = Capybara.current_session
browser.visit 'http://bellroy.com/sitemap.xml'
#urls = Nokogiri::XML(browser.body).css("url loc").map(&:text).select{|url| url=~/products\//}
urls = ['http://bellroy.com/products/card-sleeve-wallet']
prices = []
urls.each do |url|
  browser.visit url
  options = browser.all('option').map(&:text)
  options << 'Default' if options.empty?
  options.each do |option|
    browser.select option if option!= 'Default'
    prices = browser.all('.product-color-selector-title').map(:&text).map{ |price| price.split('-').strip }
    prices << browser.find('.price').text if prices.empty?
    prices.each do |price|
      prices << format_price(url, option, price)
    end
  end
end
browser = Capybara.current_session
browser.visit 'http://bellroy.com/sitemap.xml'
#urls = Nokogiri::XML(browser.body).css("url loc").map(&:text).select{|url| url=~/products\//}
urls = ['http://bellroy.com/products/card-sleeve-wallet']
prices = []
urls.each do |url|
  browser.visit url
  options = browser.all('option').map(&:text)
  options << 'Default' if options.empty?
  options.each do |option|
    browser.select option if option!= 'Default'
    prices = browser.all('.product-color-selector-title').map(&:text).map{ |price| price.split('-').strip }
    prices << browser.find('.price').text if prices.empty?
    prices.each do |price|
      prices << format_price(url, option, price)
    end
  end
end
require_relative 'setup_capybara'
browser = Capybara.current_session
urls = ['http://bellroy.com/products/card-sleeve-wallet']
browser.visit urls.first
options = browser.all('option').map(&:text)
prices = browser.all('.product-color-selector-title').map(&:text).map{ |price| price.split('-').strip }
prices << browser.find('.price').text if prices.empty?
def format_price(url, size, price)
  "url:#{url}, size:#{size}, price:#{price}"
end
prices << 
prices << format_price(url, option, price)
prices << format_price('hola', option, price)
urls = ['http://bellroy.com/products/card-sleeve-wallet']
prices = []
urls.each do |url|
  browser.visit url
  options = browser.all('option').map(&:text)
  options << 'Default' if options.empty?
  options.each do |option|
    browser.select option if option!= 'Default'
    prices = browser.all('.product-color-selector-title').map(&:text).map{ |price| price.split('-').strip }
    prices << browser.find('.price').text if prices.empty?
    prices.each do |price|
      prices << format_price(url, option, price)
    end
  end
end
I18n.t("productpage")
I18n.t("aboutus.title")
I18n.t("en.aboutus.title")
I18n.t("aboutus.title")
t("productpage.features")
I18n.t("productpage.features")
I18n.t("productpage")"
I18n.t("productpage")
I18n.t("productpage")[:feature]
I18n.t("productpage")[:all_conditions_phone_pocket][:feature]
I18n.t("productpage")[:all_conditions_phone_pocket][:feature][1]
I18n.t("productpage")[:all_conditions_phone_pocket][:feature]["1"]
I18n.t("productpage")[:all_conditions_phone_pocket][:feature]
I18n.t("productpage")[:all_conditions_phone_pocket][:feature][:1]
I18n.t("productpage")[:all_conditions_phone_pocket][:feature][:"1"]
I18n.t("productpage")[:all_conditions_phone_pocket][:feature].keys
I18n.t("productpage")[:all_conditions_phone_pocket][:feature][:variants]
exit
customized
I18n.t("productpage.#{human_key}.feature.customized")
I18n.t("productpage.#{human_key}.feature")
I18n.t("productpage.#{human_key}.feature.customized")
exit
customized
I18n.t("productpage.#{human_key}.feature.customized", default: nil)
I18n.t("productpage.#{human_key}.feature.customized", default: "nil")
I18n.t("productpage.#{human_key}.feature.customized", default: "")
I18n.t("productpage.#{human_key}.feature.customized", default: "")exit
exit
customized
n
customized
customized[:leather]
customized[:leather].class
customized[:leather].each{|k,v| puts k}
n
result
n
v1
n
exit
v1
v1.each{|k,v| puts k,v}
exit
v1
customized
exit
v1
v1.keys
n
k2
[k1, k2]
features([k1, k2])
keys = [k1, k2]
copy = I18n.t("productpage.#{human_key}.feature.#{keys.join('.')}.#{index}", default: 'missing')
copy = I18n.t("productpage.#{human_key}.feature.#{keys.join('.')}", default: 'missing')
copy = I18n.t("productpage.#{human_key}.feature.#{keys.join('.')}.#{index}", default: 'missing')
copy = I18n.t("productpage.#{human_key}.feature.#{keys.join('.')}.#{1}", default: 'missing')
"productpage.#{human_key}.feature.#{keys.join('.')}.#{1}"
keys.prepend 'customized'
copy = I18n.t("productpage.#{human_key}.feature.#{keys.join('.')}.#{1}", default: 'missing')
exit
i18n.unused_keys
exit
customized
exit
require '../'
require './'
require '/'
require '.'
require 'pathname'
Pathname.new '.'
Pathname.new '../'
Rails.root
_FILE_
Pathname.new('/home/sadhu/Projects/bellroy/app/presenters/product/style_presenter/feature_list.rb').relative_path_from('.')
Pathname.new('/home/sadhu/Projects/bellroy/app/presenters/product/style_presenter/feature_list.rb').relative_path_from('./')
Pathname.new('/home/sadhu/Projects/bellroy/app/presenters/product/style_presenter/feature_list.rb').relative_path_from(Pathname.new('.'))
Pathname.new('/home/sadhu/Projects/bellroy/app/presenters/product/style_presenter/feature_list.rb').relative_path_from(Pathname.new('./'))
page
page.body
exit
open_and_save_page
exit
require 'launchy'
open_and_save_page
save_and_open_screenshot
save_and_open_page
save_and_open_screenshot
exit
save_and_open_page
I18n
I18n.t
I18n.t 'productpage.slim_sleeve_feature'
I18n.t 'productpage.slim_sleeve.feature'
exit
I18n.t 'productpage.slim_sleeve.feature'
Product:StylePresenter.new("slim_sleeve").all_feature_lists
Product:StylePresenter::FeatureList.new("slim_sleeve").all_feature_lists
Product
Product:StylePresenter::FeaturesList.new("slim_sleeve").all_feature_lists
Product:StylePresenter
Product::StylePresenter::FeatureList.new("slim_sleeve").all_feature_lists
exit
Product::StylePresenter::FeatureList.new("slim_sleeve").all_feature_lists
exit
variant
frature_lists
feature_lists
feature_lists.keys
feature_lists.keys.include?('1')
feature_lists.keys.include?(:'1')
i18n
I18n
I18n.t
Product::StylePresenter::FeatureList.new('note_sleeve').all_feature_lists
exit
variant
feature_lists
feature_lists.keys
feature_lists.keys.first
feature_lists.keys.first.class
exit
feature_lists.keys.include?(:'1')exit
exit
product
product.variant
exit
product
product.product_code
exit
product.product_code
exit
ProductQuery.all_products
Product::RangePresenter.new.first_in_stock_or_default('phones')
Product::RangePresenter.new(nil,nil,nil,nil).first_in_stock_or_default('phones')
default_color_for_category(category)
step
first_in_stock_or_default(category)
available_colors.first
step
product_style.range_settings(category)
(product_style.range_settings(category) || {})
(product_style.range_settings(category) || {})['display_color']
range_color.present?
product_in_stock?(color: range_color)
n
available_colors
available_colors.find { |available_color| product_in_stock?(color: available_color) }
product
self.product
self
self.product_style
exit
app.sitemap_url
app.sitemap_path
nil.blank?
'video.bellroy.com' =~ /bellroy/
'video.bellroy.com'.include('bellroy')
'video.bellroy.com'.include?('bellroy')
URI.parse(nil)
URI.parse(')
URI.parse('')
URI.parse('#')
URI.parse("mailto:?subject=Carry%20Better%20with%20Bellroy&body=Hey%20%5Byour%20friend%E2%80%99s%20name%5D%2C%0AEver%20thought%20about%20those%20things%20you%20carry%20with%20you%20everyday%3F%20Organize%20your%20pockets%20and%20move%20more%20freely%20with%20these%20carry%20tips%20from%20Bellroy.%20%0ACheck%20out%20the%20tips%20here%3A%20http%3A%2F%2Fbit.ly%2Fbellroyeverydaytips%0A%E2%80%9CLimit%20everything%20to%20the%20essential%20but%20do%20not%20remove%20the%20poetry.%E2%80%9D%20%E2%80%93%20Dieter%20Rams%0ACarry%20Better%2C%20Go%20There")
URI::parse('mailto:l@a.com?Subject=Hello&body=Hi!')
URI.parse "http://localhost:3000"
uri = URI.parse "http://localhost:3000"
uri.host
default_url_options[:host]
host
n
exit
URI.parse('barneys.com/bellroy-special-range').host
URI.parse("barneys.com/bellroy-special-range").host
URI.parse("www.barneys.com/bellroy-special-range").host
URI.parse("www.barneys.com/bellroy-special-range")
uri ? URI.parse("www.barneys.com/bellroy-special-range")
uri = URI.parse("www.barneys.com/bellroy-special-range")
uri.host
uri = URI.parse("http://www.barneys.com/bellroy-special-range")
uri.host
element
element.text
element.property
element[:property]
element[:content]
exit
temp
joins("JOIN raw_saasu_invoice_list_items on invoices.invoice_number = raw_saasu_invoice_list_items.invoice_number")
temp
temp.where('(total_amount_incl_tax_aud/fc_to_bc_fx_rate) = total_amount_incl_tax_local')
t=temp.first
t
t.fc_to_bc_fx_rate
n
s
n
s
n
continue
exit
continue
contact_segment
invoice_number_obj.retail_order?
exit
AppConfig.settings['automated_sending_wholesale_invoices']['blacklist']
AppConfig.settings['automated_sending_wholesale_invoices']['blacklist']['pty_ltd']
file_identifier.to_s.downcase
exit
invoice.wholesale?
!invoice.contact.blacklisted?
exit
continue
target_database_name.to_sym
ActiveRecord::Base.establish_connection(target_database_name.to_sym)
ActiveRecord::Base.connection
self
self.superclass
self.super
self.class
self.class.super
self.class.superclass
self.class.superclass.class
self.class.superclass
self.class.superclass.methods
self.class.superclass.method? 'perform'
self.class.superclass.method 'perform'
self.class.superclass.method 'async_perform'
self.class.superclass.method 'perform_async'
country_code,
country_code
tax_code
VatDetails.find_by(country: country_code, tax_code: tax_code, date: date).present?
exit
vat_registered
n
canadian_tax
tax_name
CanadaCustomerInvoicePresenter.new(shop_order)
ip = _
ip
ip.provincial_registration_number
AppConfig.settings['canada_tax']
exit
n
klass
second_element
first_element
second_element
continue
n
second_element
first_element
continue
n
class
  klass
n
exit
first_element
second_element
n
first_element
exit
@grouped_data
@grouped_data.class
data
data.class
exit
@grouped_data
@grouped_data ||= data.group_by do |row|
  121:     row['transaction-type']
122:   end@roup|u|
ENV['HOME']
File.read(File.join(ENV['HOME'], '.slack_api_key'))
exit
exit
saasu_client_invoice
saasu_client_invoice.method(:date)
saasu_client_invoice.method(:date).source
saasu_client_invoice.method(:date).source.display
saasu_client_invoice.method(:date).source
exit
row[column :transaction_type]
VALUES.index(row[column :transaction_type])
VALUES[:en].index(row[column :transaction_type])
exit
row[column :amount_description]
self.class.normalized_value(row[column :amount_description])
continue
self.class.normalized_value(row[column :amount_description])
exit
self.class.normalized_value(row[column :amount_description])
exit
c
current_reserve_row
rows.find do |row|
  69:     row.amount_description == :current_reserve_amount
70:   end
n
current_reserve_row
rows
rows.first
rows.first.amount_description
SettlementRow.new(rows.first)
sr = SettlementRow.new(rows.first)
sr.amount_description
sr.amount
sr.class
row
row.sku
sr.sku
@rows
@rows.first
@rows.first.methods
@rows.first.amount
@rows.first.amount_description
@rows.first
exit
@rows.first.amount_description
exit
n
column :amount_description
row[column :amount_description]
exit
n
description
normalized_value(description) || description
n
description
n
description
continue
description
n
description
continue
description
n
description
exit
header
data
exit
data
exit
column(:currency)
COLUMN_NAMES
detect_language
header.first.first == self.class.column(lang, :settlement_id)
header.first.first == self.class.column(:en, :settlement_id)
header.first.first == self.class.column(:fr, :settlement_id)
header.first.first
header
data
header
data
data.to_a
exit
olumn(:curreneader[olumn(:currhader[colum(:currency)]
en
      hader[column(:currncy)]
eeei
rows
exit
total_imported
total_imported.to_f
total.to_f
current_reserve.to_f
previous_reserve.to_f
1794.73 + 81.66
1794.73 - 81.66
1713.07+81.66
order.map(&:value).sum
orders.map(&:value).sum
orders.map(&:value).sum.to_f
refunds.map(&:value).sum.to_f
other_transactions.map(&:value).sum.to_f
[other_transactions].map(&:value).sum.to_f
orders
orders.last
orders.count
orders.to_hash
orders.map(&:to_hash)
exit
refunds.map(&:to_hash)
exit
account
n
settlement_start_date >= cutover_date(V2::TRADING_FILE)
exit
translations.values
exit
e
cc
dscdeds
e
ecdscds
desc
REIMBURSEMENT_DESCRIPTIONS
exit
row
row.amount_description
continue
exit
grouped_data[transaction_type_value(:service_fee)]
grouped_data[transaction_type_value(:other_transaction)]
[
  185:     grouped_data[transaction_type_value(:service_fee)],
  186:     grouped_data[transaction_type_value(:other_transaction)]
a = [
  grouped_data[transaction_type_value(:service_fee)],
  grouped_data[transaction_type_value(:other_transaction)]
]
a[1].size
a.compact
a.compact.flatten
a.compact == a
grouped_data
grouped_data['hola']
grouped_data['jajaja']
exit
products = tile.tile_products.sort_by(&:display_index).map(&:product)
products.first
products.first.class
exit
disabled_product
disabled_product.sku
n
m
n
exit
tile_hash
tile_hash[:products]
tile_hash[:products].count
exit
Maxwell::ProductStyle::STATES
Maxwell::ProductStyle.statuses
Maxwell::ProductStyle.states
Maxwell::ProductStyle.states_active
Maxwell::ProductStyle.states["active"]
Maxwell::ProductStyle.states.class
Maxwell::ProductStyle.states.method
Maxwell::ProductStyle.states.methods
Maxwell::ProductStyle.states.active
exitç
exit
all
n
exit
where(product_id: nil).count
n
exit
invoice_line
n
raw_inventory_item
n
product_sku
Transformed::Bellroy::Product
14:       .matching_sku(product_sku)
product_id = Transformed::Bellroy::Product.matching_sku(product_sku)
product_id = Transformed::Bellroy::Product.matching_sku(product_sku).try)(:id)
product_id = Transformed::Bellroy::Product.matching_sku(product_sku).try(:id)
product_id
product_id = Transformed::Bellroy::Product.matching_sku(product_sku).class
Transformed::Bellroy::Product.matching_sku(product_sku).class
Transformed::Bellroy::Product.matching_sku(product_sku).first
Transformed::Bellroy::Product.matching_sku(product_sku).first.id
exit
Transformed::Bellroy::Product.matching_sku(product_sku).count
Transformed::Bellroy::Product.all.count
Transformed::Bellroy::Product.all.first
exit
Transformed::Bellroy::Product.all.count
Transformed::Bellroy::Product.matching_sku(product_sku).count
Transformed::Bellroy::Product.all.count
Transformed::Bellroy::Product.all
Transformed::Bellroy::Product.where('LOWER("MAAP" = ?', "MAAP".sku)
Transformed::Bellroy::Product.where('LOWER("MAAP" = ?', "MAAP".downcase)
Transformed::Bellroy::Product.where('LOWER("MAAP" = ?', "MAAP".downcase).count
Transformed::Bellroy::Product.where('LOWER("MAAP") = ?', "MAAP".downcase).count
Transformed::Bellroy::Product.where('LOWER(MAAP) = ?', "MAAP".downcase).count
exit
n
exit
Transformed::Bellroy::Product.all.count
Transformed::Bellroy::Product.all
n
product_id
product_sku
exit
subject
described_class.rules[60]
exit
n
exit
invoice
invoice.code
invoice.code.invoice_items
invoice.invoice_items
invoice.invoice_items.code
invoice.invoice_items.quantity
invoice.invoice_items.send(:quantity)
invoice.invoice_items.item_hash
invoice.invoice_items.last
invoice.invoice_items.first
invoice.invoice_items.send(:item_hash)
invoice.invoice_items.first
invoice.invoice_items.first.class
invoice.invoice_items.last.quantity
exit
invoice.invoice_items
invoice.invoice_items[0]
invoice.invoice_items[0].code
invoice.invoice_items[0].quantity
invoice.invoice_items.count
invoice.invoice_items
invoice.invoice_items.count
invoice_item
invoice_item.code
invoice_item.quantity
invoice_item.item_hash
exit
invoice_item
invoice
exit
invoice
invoice.invoice_items
invoice.invoice_items.count
invoice.invoice_items.first
invoice.invoice_items.first.code
invoice.invoice_items.first
invoice.invoice_items.first.ccy
exit
invoice.invoice_items
invoice.invoice_items.count
exit
invoice.invoice_items
invoice.invoice_items.count
exit
saasu_invoice.invoice_items
invoice.invoice_items
invoice.invoice_items.count
invoice.invoice_items
exit
fixture
nxml
saasu_invoice
nxml
nxml.xpath('//invoice/invoiceItems')
nxml.xpath('//invoice/invoiceItems').children
nxml.xpath('//invoice/invoiceItems').children.count
nxml.xpath('//invoice/invoiceItems').children.map {|x| x.class}
nxml.xpath('//invoice/invoiceItems').children.class
nxml.xpath('//invoice/invoiceItems').children.reject(&:text?)
nxml.xpath('//invoice/invoiceItems').children.reject(&:text?).count
invoice.invoice_items
exit
sku
warehouse
available_stock
available_stock["ABC"]
available_stock[:ABC]
exit
shippable_edi_nordstrom_purchase_orders.count
shippable_edi_nordstrom_purchase_orders
exit
exit\
exit
shippable_edi_nordstrom_purchase_orders.count
exit
EdiNordstromOrder.last
EdiNordstromOrder.last.purchase_order
EdiNordstromOrder.last.edi_nordstrom_purchase_order
EdiNordstromPurchaseOrder
EdiNordstromPurchaseOrder.count
EdiNordstromOrder.count
EdiNordstromPurchaseOrder.first
EdiNordstromPurchaseOrder..edi_nordstrom_orders.count
EdiNordstromPurchaseOrder.edi_nordstrom_orders.count
EdiNordstromPurchaseOrder.first.edi_nordstrom_orders.count
EdiNordstromPurchaseOrder.first.edi_nordstrom_orders.first
n
exit
n
shippable_edi_nordstrom_purchase_orders
exit
shippable_edi_nordstrom_purchase_orders
exit
shippable_edi_nordstrom_purchase_orders
shippable_edi_nordstrom_purchase_orders.first
shippable_edi_nordstrom_purchase_orders.first.shippable?
shippable_edi_nordstrom_purchase_orders.last.shippable?
EdiNordstromPurchaseOrder.first.shippable?
EdiNordstromPurchaseOrder.all.map(&:shippable?)
rspec /home/sadhu/Projects/bellroy-logistics/spec/jobs/edi_nordstrom_poller_job_spec.rb
edi_nordstrom_purchase_order
exit
exity
exit
is_shippable
edi_nordstrom_purchase_orderexit
exit
\exiut\
exit
edi_nordstrom_purchase_order
edi_nordstrom_purchase_order.edi_nordstrom_orders
edi_nordstrom_purchase_order.edi_nordstrom_orders.first
is_shippable
n
is_shippable
n
exit
edi_nordstrom_purchase_order
edi_nordstrom_purchase_order.edi_nordstrom_orders
exit
insufficient_skus
stock_required
edi_nordstrom_orders
edi_nordstrom_orders.count
exit
stock_required
edi_nordstrom_orders.map(&:stock_required)
stock_required
invoice1
invoice
exit
required_stock
stock_required
exit
invoice.invoice_items
invoice.invoice_items.count
continue
invoice.invoice_items.count
continue
invoice.invoice_items.count
continue
invoice.invoice_items.count
exit
EdiNordstromPurchaseOrder
EdiNordstromPurchaseOrder.count
EdiNordstromPurchaseOrder.first
EdiNordstromPurchaseOrder.second
EdiNordstromPurchaseOrder.third
EdiNordstromPurchaseOrder.first.edi_nordstrom_orders
EdiNordstromPurchaseOrder.second.edi_nordstrom_orders
EdiNordstromPurchaseOrder.third.edi_nordstrom_orders
EdiNordstromPurchaseOrder.first.edi_nordstrom_orders
EdiNordstromPurchaseOrder.last
EdiNordstromPurchaseOrder.first.edi_nordstrom_orders
EdiNordstromPurchaseOrder.first.edi_nordstrom_orders.invoice
EdiNordstromPurchaseOrder.first.edi_nordstrom_orders.send(:invoice)
EdiNordstromPurchaseOrder.first.edi_nordstrom_orders.first
EdiNordstromPurchaseOrder.first.edi_nordstrom_orders.first.send(:invoice)
EdiNordstromPurchaseOrder.first.edi_nordstrom_orders.second.send(:invoice)
EdiNordstromPurchaseOrder.first.edi_nordstrom_orders.second
EdiNordstromPurchaseOrder.first.edi_nordstrom_orders.second.send(:invoice)
exit
EdiNordstromOrder
EdiNordstromPurchaseOrder
EdiNordstromPurchaseOrder.first
EdiNordstromPurchaseOrder.first.edi_nordstrom_orders
EdiNordstromPurchaseOrder.first.edi_nordstrom_orders.last
EdiNordstromPurchaseOrder.first.edi_nordstrom_orders.last.send(:invoice)
git st
exit
Order.first
User.first
a = User.first
a.email = 'carlos@trikeapps.com'
a.changes
item['TYPE']
item\
item
order_record_items
settlement_hash
exit
settlement_hash
quantity
line_price
order_record_items
settlement_hash
item
exit
item
exit
item
item.class
3.in?([4,5])
3.in?([4,3])
exirt
exit
quantity
raw_quantity
quantity
exit
raw_quantity
quantity
exit
quantity
raw_quantity
exit
quantity
raw_quantity
exit
quantity
should_negate_quantity_and_price?
temp_unit_price = raw_unit_price
temp_quantity = raw_quantity
temp_quantity *= -1 if should_negate_quantity_and_price?
temp_quantity
quantity
exit
exoexit
item
exit
params
params[:variables]
params
params[:popup]
exit
params
exit
params
params[:popup]
exit
edi_nordstrom_orders.count
edi_nordstrom_orders.count.skippable(false)
edi_nordstrom_orders.skippable(false)
edi_nordstrom_orders.skippable(false).count
edi_nordstrom_orders
edi_nordstrom_orders = edi_nordstrom_orders.skippable(false)
edi_nordstrom_orders == edi_nordstrom_orders.skippable(false)
edi_nordstrom_orders
exit
edi_nordstrom_orders
edi_nordstrom_orders == edi_nordstrom_orders.skippable(false)
exit
purchase_order_number
exit
migration_structs
migration_structs.first
migration_structs.class
migration_structs.first
migration_structs.first.migration
exit
ActiveRecord::Base.connection.tables - ["schema_migrations", "ar_internal_metadata"]
ActiveRecord::Base.descendants
ActiveRecord::Base.connection.tables.map do |model|
  model.capitalize.singularize.camelize
end
ActiveRecord::Base.descendants
ActiveRecord::Base.connection.tables
ActiveRecord::Base.connection.tables.count
ActiveRecord::Base.connection.tables
ActiveRecord::Base.descendants
ActiveRecord::Base.descendants.count
ActiveRecord::Base.descendants
ActiveRecord::Base.descendants.first
ActiveRecord::Base.subclasses
ActiveRecord::Base.subclasses.count
exit
model
model.classify
model.classify.constatize
model.classify.constantize
ApplicationRecord.descendants
ApplicationRecord.descendants.count
ApplicationRecord.descendants
exit
ApplicationRecord.descendants
ActiveRecord.descendants
ActiveRecord::Base.subclasses
ActiveRecord::Base.subclasses.count
ActiveRecord.descendants
ActiveRecord::Base.descendants
ApplicationRecord.descendants
ApplicationRecord.descendants.first
ApplicationRecord.descendants.first.attributes
ApplicationRecord.descendants.first.columns
ApplicationRecord.descendants.first.columns.first
ApplicationRecord.descendants.first
ApplicationRecord.descendants.first.new
ApplicationRecord.descendants.first.new.created_at
ApplicationRecord.descendants.first.new.created_a
ApplicationRecord.descendants.first.new.created_at
exit
new_model
new_model.destroy
new_model.save
new_model.save!
new_model
exit
new_model
new_model.save!
new_model
new_model.destroy
new_model
exit
Kaos::ApplicationREcord
Kaos::ApplicationRecord
::Kaos::ApplicationRecord
::::Kaos::ApplicationRecord
::ApplicationRecord
::Kaos::ApplicationRecord
Kaos
Kaos::ApplicationRecord
Kaos::Application
exit
::Kaos::ApplicationRecord
::UserBehavior::ApplicationRecord
::UserBehaviour::ApplicationRecord
UserBehaviour::ApplicationRecord
::UserBehaviour::ApplicationRecord
Kaos::ApplicationRecord
Kaos
Kaos.classed
Kaos.classes
Kaos.class
exit
Kaos::ApplicationRecord
exit
Kaos::TaxConfig::Code
::TaxConfig::Code
::Kaos::TaxConfig::Code
Kaos::TaxConfig
exit
exiut
new_model
new_model.new
new_model.destroy
new_model.destroy!
n = new_model.save!
n
nn
exit
n
ja = new_model.save!
exit
ja = new_model.save!
exit
ja = new_model.save!
ja
ja.destroy
new_model
new_model.destroy
new_model
new_model.destroy
new_model.destroy!
exit
new_model.save!
new_model.destroy
exit
new_model.save!
exit
new_model.save!
new_model.save!(false)
new_model.save\(false)
new_model.save(false)
new_model.save(validate: false)
exit
model.attributes
model.methods
model.paranoia_column
model.methods
model.column_names
model
model.abstract?
model.abstract_class?
model.concrete_class?
exit
tables
exit
new_model
new_new_model.save!
new_model.save!
new_model
new_model.to_json
user
Kaos::Security::User
exit
Kaos::Security::User.with_deleted
Kaos::Security::User
Kaos::Security::User.all
exitq
exit
User.count
User.new
User.new(email:'carlos@trikeapps.com', full_name: 'Carlos Rojas')
u = User.new(email:'carlos@trikeapps.com', full_name: 'Carlos Rojas')
u.save!
UserRole
Role
u.password = '1234'
u.save!
u.password = '12345678'
u.save!
u.role = :admin
u.role = 'admin'
u.save!
exit
step
Creative
c = Creative.new
exit
Creative
Creative.new
c = Creative.new
creative = Creative.new
creative.creative_name = 'Carlos'
creative.save!
Creative.count
Creative.last
carlos = Creative.last
carlos.destroy
EXIT
exit
id
user_role = Kaos::Security::UserRole.find_by(name: 'admin')
Kaos::Security::UserRole
Kaos::Security::UserRole.all
exit
user_role = Kaos::Security::UserRole.find_by(name: 'Admin')
exit
Kaos::Security::UserRoleMembership.exists?(user_role_id: user_role.try(:id), user_id: id)
user_role
id
exit
BellroyAdValidator::Asset::NAME_REGEX.match(creative_name).presence || {}
s
exit
creative_name
self
CreativeImage.new(self).resize_to(size)
exit
Rails.application.secrets['api_keys'].first
Rails.application.secrets['api_keys']
Rails.application.secrets
Rails.application
exit
response.body
exit
response.body
exit
(JSON.parse(response.body)
JSON.parse(product_style_version.manifest)
exit
JSON.parse(response.body)
results
Kaos::ProductConfig::Offering
Kaos::ProductConfig::Offering.all
exit
results
exit
results
exit
results
Kaos::ProductConfig::Dimension.all
exit
results
exit
results
exit
results
results.group_by{|offering| offering['value']}
results.group_by{|offering| offering['value']}.map{|k,v| v.map(&:id)}
results.group_by{|offering| offering['value']}.map{|k,v| v.map{|h| h['id']}}
results.group_by{|offering| offering['value']}.map{|k,v| [k, v.map{|h| h['id']}].to_h}
results.group_by{|offering| offering['value']}.map{|k,v| [k, v.map{|h| h['id']}]}
results.group_by{|offering| offering['value']}.map{|k,v| [k, v.map{|h| h['id']}]}.to_h
results.group_by{|offering| offering['value']}.map{|k,v| [k, Kaos::ProductConfig::Product.find(v.map{|h| h['id']})]}.to_h
index
JSON.parse response.body
exit
qexit
exit
index
Kaos::ProductConfig::Offering
Kaos::ProductConfig::Offering.group_by_code
Kaos::ProductConfig::Offering.group_by_style
exit
style_code
product
product.sku
product['sku']
product.send(:sku)
product.id
product
productexit
exit
v1_products_array.last
v1_products_array.last.select{|style| style['code'] == 'WWSB'}
v1_products_array.elect{|style| style['code'] == 'WWSB'}
v1_products_array.select{|style| style['code'] == 'WWSB'}
v1_products_array.select{|style| style['code'] == 'WVSB'}
v1_products_array.find{|style| style['code'] == 'WVSB'}
v1_products_array.find{|style| style['code'] == 'WVSB'}exit
exit
products
products.group_by(&:variant_id)
products.group_by{|p| p['variant_id']}
products.group_by{|p| p['variant_id']}exit
exit
step
next
exit
variant
products.group_by{|p| p['product_variant_id']}
products.group_by{|p| p['product_variant_id']}exit
exit
variant
variant.variant_id
variant.id
variant
exit
variants
variants.first
exit
asset
asset.image
asset.image.queued_for_write
Kaos::Image
Kaos::Product::Config
Kaos::Asset
Kaos::Asset.last
exit
value
next
value.class
value.image
next
upload.queued_for_write[:original]
next
dimensions.width
dimensions.height
image.size
exit
continue
asset.image
asset.image.width
exit
dimensions
exit
dimensions
exit
upload
image.content_type
image
upload.content_type
exit
width_options.merge(attributes: attribute)
next
exit
options
exit
options
exit
options
width_options
ActiveModel::Errors.generate_error
exit
image.size
size
continue
size
image.size
exit
IMAGES_DIRECTORY = 'app/assets/images/product'
path_pattern = Rails.root.join(IMAGES_DIRECTORY, '**', '*').to_s
IMAGES_DIRECTORY = 'app/assets/images/product'
path_pattern = Rails.root.join(IMAGES_DIRECTORY, '**', '*').to_s
all_product_image_paths ||= Dir.glob(path_pattern).select do |file|
  File.file?(file)
end
Dir.entries(IMAGES_DIRECTORY)
Dir.glob(IMAGES_DIRECTORY)
CSV.open("db/images.csv", "wb") do |rows|
  rows << ['sku', 'currency_code', 'path']
  image_manifest = Product::ImageManifest.instance
  manifests = image_manifest.send(:manifests)
  manifests.each do |style_code, image_list|
    style = ProductQuery.find_style_by_code(style_code)
    image_list.each do |image_hash|
      product = style.find_product(color: image_hash[:color], variant_name: image_hash[:variant_name])
      rows << [product.sku, image_hash[:currency_code], image_hash[:path]]
    end
  end
end
def generate_images_csv
  CSV.open("db/images.csv", "wb") do |rows|
    rows << ['sku', 'currency_code', 'path']
    image_manifest = Product::ImageManifest.instance
    manifests = image_manifest.send(:manifests)
    manifests.each do |style_code, image_list|
      style = ProductQuery.find_style_by_code(style_code.upcase)
      image_list.each do |image_hash|
        product = style.find_product(color: image_hash[:color], variant_name: image_hash[:variant_name])
        rows << [product.sku, image_hash[:currency_code], image_hash[:path]]
      end
    end
  end
end
generate_images_csv
def generate_images_csv
  CSV.open("db/images.csv", "wb") do |rows|
    rows << ['sku', 'currency_code', 'path']
    image_manifest = Product::ImageManifest.instance
    manifests = image_manifest.send(:manifests)
    manifests.each do |style_code, image_list|
      style = ProductQuery.find_style_by_code(style_code.upcase)
      image_list.each do |image_hash|
        product = style.find_product(color: image_hash[:color], variant_name: image_hash[:variant_name])
        if product.nil?
          puts "Couldn't find the product for color:#{image_hash[:color]}, variant_name: #{image_hash[:variant_name]}"
        end
        rows << [product.sku, image_hash[:currency_code], image_hash[:path]]
      end
    end
  end
end
generate_images_csv
def generate_images_csv
  CSV.open("db/images.csv", "wb") do |rows|
    rows << ['sku', 'currency_code', 'path']
    image_manifest = Product::ImageManifest.instance
    manifests = image_manifest.send(:manifests)
    manifests.each do |style_code, image_list|
      style = ProductQuery.find_style_by_code(style_code.upcase)
      image_list.each do |image_hash|
        product = style.find_product(color: image_hash[:color], variant_name: image_hash[:variant_name])
        if product.nil?
          puts "Couldn't find the product for color:#{image_hash[:color]}, variant_name: #{image_hash[:variant_name]}"
          next
        end
        rows << [product.sku, image_hash[:currency_code], image_hash[:path]]
      end
    end
  end
end
generate_images_csv
# end
def get_products_per_image_hash(style, image_hash)
  variant_name = image_hash[:variant_name]
  return style.products if variant_name.blank?
  variants = variant_name.split('__')
  variants.flat_map do |variant|
    style.variants.find { |v| v.name == variant }.products
  end
end
def generate_images_csv
  CSV.open("db/images.csv", "wb") do |rows|
    rows << ['sku', 'currency_code', 'path']
    image_manifest = Product::ImageManifest.instance
    manifests = image_manifest.send(:manifests)
    manifests.each do |style_code, image_list|
      style = ProductQuery.find_style_by_code(style_code.upcase)
      image_list.each do |image_hash|
        get_products_per_image_hash(style, image_hash).each do |product|
          rows << [product.sku, image_hash[:currency_code], image_hash[:path]]
        end
      end
    end
  end
end
generate_images_csv
def get_products_per_image_hash(style, image_hash)
  variant_name = image_hash[:variant_name]
  return style.send(:products) if variant_name.blank?
  variants = variant_name.split('__')
  variants.flat_map do |variant|
    style.variants.find { |v| v.name == variant }.products
  end
end
generate_images_csv
def get_products_per_image_hash(style, image_hash)
  variant_name = image_hash[:variant_name]
  return style.send(:products) if variant_name.blank?
  variants = variant_name.split('__')
  products = variants.flat_map do |variant|
    style.variants.find { |v| v.name == variant }.products
  end
  if image_hash[:color].present?
    products.select!{ |product| product.color == image_hash[:color] }
  end
  products
end
generate_images_csv
def get_products_per_image_hash(style, image_hash)
  variant_name = image_hash[:variant_name]
  return style.send(:products) if variant_name.blank?
  variants = variant_name.split('__')
  products = variants.flat_map do |variant|
    style.variants.find { |v| v.name == variant }.products
  end.reject(&:disabled?)
  if image_hash[:color].present?
    products.select!{ |product| product.color == image_hash[:color] }
  end
  products
end
def get_image_class_for_image_hash(image_hash)
  case image_hash[:group]
  when 'product_explode'
    'BellroyDotCom::ProductExplodeImage'
  when 'product_gallery'
    'BellroyDotCom::GalleryImage'
  when 'product_sketch'
    'BellroyDotCom::ProductSketchImage'
  when 'product_slider'
    'BellroyDotCom::LifestyleSliderImage'
  when 'range'
    'BellroyDotCom::RangePageImage'
  when 'range_exploded_hovers'
    'BellroyDotCom::RangePageExplodeImage'
  else
    raise "Couldn't find the appropiatte image role."
  end
end
def generate_images_csv
  CSV.open("db/images.csv", "wb") do |rows|
    rows << ['sku', 'currency_code', 'path', 'class']
    image_manifest = Product::ImageManifest.instance
    manifests = image_manifest.send(:manifests)
    manifests.each do |style_code, image_list|
      style = ProductQuery.find_style_by_code(style_code.upcase)
      image_list.each do |image_hash|
        get_products_per_image_hash(style, image_hash).each do |product|
          rows << [product.sku, image_hash[:currency_code], image_hash[:path], get_image_class_for_image_hash(image_hash)]
        end
      end
    end
  end
end
generate_images_csv
def get_image_class_for_image_hash(image_hash)
  case image_hash[:group]
  when 'product_explode'
    'BellroyDotCom::ProductExplodeImage'
  when 'product_gallery'
    'BellroyDotCom::GalleryImage'
  when 'product_sketch'
    'BellroyDotCom::ProductSketchImage'
  when 'product_slider'
    'BellroyDotCom::LifestyleSliderImage'
  when 'range'
    'BellroyDotCom::RangePageImage'
  when 'range_exploded_hovers'
    'BellroyDotCom::RangePageExplodeImage'
  else
    "Couldn't find the appropiatte image role."
  end
end
generate_images_csv
def get_image_class_for_image_hash(image_hash)
  case image_hash[:group]
  when 'product_explode'
    'BellroyDotCom::ProductExplodeImage'
  when 'product_gallery'
    'BellroyDotCom::GalleryImage'
  when 'product_sketch'
    'BellroyDotCom::ProductSketchImage'
  when 'product_slider'
    'BellroyDotCom::LifestyleSliderImage'
  when 'range'
    'BellroyDotCom::RangePageImage'
  when 'range_exploded_hovers'
    'BellroyDotCom::RangePageExplodeImage'
  when 'product_gallery_video'
    'BellroyDotCom::ProductPageVideoImage'
  else
    raise "Couldn't find the appropriate image role. #{image_hash[:group]}"
  end
end
generate_images_csv
def get_image_class_for_image_hash(image_hash)
  case image_hash[:group]
  when 'product_explode'
    'BellroyDotCom::ProductExplodeImage'
  when 'product_gallery'
    'BellroyDotCom::GalleryImage'
  when 'product_sketch'
    'BellroyDotCom::ProductSketchImage'
  when 'product_slider'
    'BellroyDotCom::LifestyleSliderImage'
  when 'range'
    'BellroyDotCom::RangePageImage'
  when 'range_exploded_hovers'
    'BellroyDotCom::RangePageExplodeImage'
  when 'product_gallery_video_preview'
    'BellroyDotCom::ProductPageVideoImage'
  else
    raise "Couldn't find the appropriate image role. #{image_hash[:group]}"
  end
end
generate_images_csv
def get_image_class_for_image_hash(image_hash)
  case image_hash[:group]
  when 'product_explode'
    'BellroyDotCom::ProductExplodeImage'
  when 'product_gallery'
    'BellroyDotCom::GalleryImage'
  when 'product_sketch'
    'BellroyDotCom::ProductSketchImage'
  when 'product_slider'
    'BellroyDotCom::LifestyleSliderImage'
  when 'range'
    'BellroyDotCom::RangePageImage'
  when 'range_exploded_hovers'
    'BellroyDotCom::RangePageExplodeImage'
  when 'product_gallery_video_preview'
    'BellroyDotCom::ProductPageVideoImage'
  when 'nude_approach'
    nil
  else
    raise "Couldn't find the appropriate image role. #{image_hash[:group]}"
  end
end
def generate_images_csv
  CSV.open("db/images.csv", "wb") do |rows|
    rows << ['sku', 'currency_code', 'path', 'class']
    image_manifest = Product::ImageManifest.instance
    manifests = image_manifest.send(:manifests)
    manifests.each do |style_code, image_list|
      style = ProductQuery.find_style_by_code(style_code.upcase)
      image_list.each do |image_hash|
        get_products_per_image_hash(style, image_hash).each do |product|
          image_class = get_image_class_for_image_hash(image_hash)
          next if image_class.nil?
          rows << [product.sku, image_hash[:currency_code], image_hash[:path], image_class]
        end
      end
    end
  end
end
generate_images_csv
Rails.root.path
Rails.root
Rails.root.to_s
def generate_images_csv
  CSV.open("db/images.csv", "wb") do |rows|
    rows << ['sku', 'currency_code', 'path', 'class']
    image_manifest = Product::ImageManifest.instance
    manifests = image_manifest.send(:manifests)
    manifests.each do |style_code, image_list|
      style = ProductQuery.find_style_by_code(style_code.upcase)
      image_list.each do |image_hash|
        get_products_per_image_hash(style, image_hash).each do |product|
          image_class = get_image_class_for_image_hash(image_hash)
          next if image_class.nil?
          path = image_hash[:path]
          path.gsub!(Rails.root.to_s, '')
          rows << [product.sku, image_hash[:currency_code], path, image_class]
        end
      end
    end
  end
end
generate_images_csv
def generate_images_csv
  CSV.open("db/images.csv", "wb") do |rows|
    rows << ['sku', 'currency_code', 'path', 'class']
    image_manifest = Product::ImageManifest.instance
    manifests = image_manifest.send(:manifests)
    manifests.each do |style_code, image_list|
      style = ProductQuery.find_style_by_code(style_code.upcase)
      image_list.each do |image_hash|
        get_products_per_image_hash(style, image_hash).each do |product|
          image_class = get_image_class_for_image_hash(image_hash)
          next if image_class.nil?
          path = image_hash[:path]
          path.gsub!(Rails.root.to_s + '/', '')
          rows << [product.sku, image_hash[:currency_code], path, image_class]
        end
      end
    end
  end
end
generate_images_csv
Rails.root.to_s + '/'
def generate_images_csv
  CSV.open("db/images.csv", "wb") do |rows|
    rows << ['sku', 'currency_code', 'path', 'class']
    image_manifest = Product::ImageManifest.instance
    manifests = image_manifest.send(:manifests)
    manifests.each do |style_code, image_list|
      style = ProductQuery.find_style_by_code(style_code.upcase)
      image_list.each do |image_hash|
        get_products_per_image_hash(style, image_hash).each do |product|
          image_class = get_image_class_for_image_hash(image_hash)
          next if image_class.nil?
          path = image_hash[:path]
          path.gsub!("#{Rails.root}/", '')
          rows << [product.sku, image_hash[:currency_code], path, image_class]
        end
      end
    end
  end
end
generate_images_csv
def generate_images_csv
  CSV.open("db/images.csv", "wb") do |rows|
    rows << ['sku', 'currency_code', 'path', 'class']
    image_manifest = Product::ImageManifest.instance
    manifests = image_manifest.send(:manifests)
    manifests.each do |style_code, image_list|
      style = ProductQuery.find_style_by_code(style_code.upcase)
      image_list.each do |image_hash|
        get_products_per_image_hash(style, image_hash).each do |product|
          image_class = get_image_class_for_image_hash(image_hash)
          next if image_class.nil?
          path = image_hash[:path].gsub("#{Rails.root}/", '')
          rows << [product.sku, image_hash[:currency_code], path, image_class]
        end
      end
    end
  end
end
generate_images_csv
"hola"[1..]
"hola".slice(1)
"hola"[1..-1]
def generate_images_csv
  CSV.open("db/images.csv", "wb") do |rows|
    rows << ['sku', 'currency_code', 'path', 'class']
    image_manifest = Product::ImageManifest.instance
    manifests = image_manifest.send(:manifests)
    manifests.each do |style_code, image_list|
      style = ProductQuery.find_style_by_code(style_code.upcase)
      image_list.each do |image_hash|
        get_products_per_image_hash(style, image_hash).each do |product|
          image_class = get_image_class_for_image_hash(image_hash)
          next if image_class.nil?
          path = image_hash[:path]
          rows << [product.sku, image_hash[:currency_code], path[1,-1], image_class]
        end
      end
    end
  end
end
generate_images_csv
def generate_images_csv
  CSV.open("db/images.csv", "wb") do |rows|
    rows << ['sku', 'currency_code', 'path', 'class']
    image_manifest = Product::ImageManifest.instance
    manifests = image_manifest.send(:manifests)
    manifests.each do |style_code, image_list|
      style = ProductQuery.find_style_by_code(style_code.upcase)
      image_list.each do |image_hash|
        get_products_per_image_hash(style, image_hash).each do |product|
          image_class = get_image_class_for_image_hash(image_hash)
          next if image_class.nil?
          path = image_hash[:path]
          rows << [product.sku, image_hash[:currency_code], path[1..-1], image_class]
        end
      end
    end
  end
end
generate_images_csv
def generate_images_csv
  CSV.open("db/images.csv", "wb") do |rows|
    rows << ['sku', 'currency_code', 'path', 'class']
    image_manifest = Product::ImageManifest.instance
    manifests = image_manifest.send(:manifests)
    manifests.each do |style_code, image_list|
      style = ProductQuery.find_style_by_code(style_code.upcase)
      image_list.each do |image_hash|
        get_products_per_image_hash(style, image_hash).each do |product|
          image_class = get_image_class_for_image_hash(image_hash)
          next if image_class.nil?
          path = image_hash[:path]
          rows << [product.sku, image_hash[:currency_code], path[1..-1], image_class]
        end
      end
    end
  end
end
generate_images_csv
def generate_images_csv
  CSV.open("db/images.csv", "wb") do |rows|
    rows << ['sku', 'currency_code', 'path', 'class']
    image_manifest = Product::ImageManifest.instance
    manifests = image_manifest.send(:manifests)
    manifests.each do |style_code, image_list|
      style = ProductQuery.find_style_by_code(style_code.upcase)
      image_list.each do |image_hash|
        get_products_per_image_hash(style, image_hash).each do |product|
          image_class = get_image_class_for_image_hash(image_hash)
          next if image_class.nil?
          path = image_hash[:path]
          rows << [product.sku, image_hash[:currency_code], path, image_class]
        end
      end
    end
  end
end
generate_images_csv
def generate_images_csv
  CSV.open("db/images.csv", "wb") do |rows|
    rows << ['sku', 'currency_code', 'path', 'class']
    image_manifest = Product::ImageManifest.instance
    manifests = image_manifest.send(:manifests)
    manifests.each do |style_code, image_list|
      style = ProductQuery.find_style_by_code(style_code.upcase)
      image_list.each do |image_hash|
        get_products_per_image_hash(style, image_hash).each do |product|
          image_class = get_image_class_for_image_hash(image_hash)
          next if image_class.nil?
          path = image_hash[:path]
          rows << [product.sku, image_hash[:currency_code], Dragonfly.app.fetch_file(Rails.root + path).url, image_class]
        end
      end
    end
  end
end
generate_images_csv
def generate_images_csv
  CSV.open("db/images.csv", "wb") do |rows|
    rows << ['sku', 'currency_code', 'path', 'class']
    image_manifest = Product::ImageManifest.instance
    manifests = image_manifest.send(:manifests)
    manifests.each do |style_code, image_list|
      style = ProductQuery.find_style_by_code(style_code.upcase)
      image_list.each do |image_hash|
        get_products_per_image_hash(style, image_hash).each do |product|
          image_class = get_image_class_for_image_hash(image_hash)
          next if image_class.nil?
          path = image_hash[:path]
          public_url = "https://staging.bellroy.it#{path}"
          rows << [product.sku, image_hash[:currency_code], Dragonfly.app.fetch_file(Rails.root + path).url, image_class]
        end
      end
    end
  end
end
generate_images_csv
def generate_images_csv
  CSV.open("db/images.csv", "wb") do |rows|
    rows << ['sku', 'currency_code', 'path', 'class']
    image_manifest = Product::ImageManifest.instance
    manifests = image_manifest.send(:manifests)
    manifests.each do |style_code, image_list|
      style = ProductQuery.find_style_by_code(style_code.upcase)
      image_list.each do |image_hash|
        get_products_per_image_hash(style, image_hash).each do |product|
          image_class = get_image_class_for_image_hash(image_hash)
          next if image_class.nil?
          path = image_hash[:path]
          public_url = "https://staging.bellroy.it#{Dragonfly.app.fetch_file(Rails.root + path).url}"
          rows << [product.sku, image_hash[:currency_code], public_url, image_class]
        end
      end
    end
  end
end
generate_images_csv
def generate_images_csv
  CSV.open("tmp/images.csv", "wb") do |rows|
    rows << ['sku', 'currency_code', 'path', 'class']
    image_manifest = Product::ImageManifest.instance
    manifests = image_manifest.send(:manifests)
    manifests.each do |style_code, image_list|
      style = ProductQuery.find_style_by_code(style_code.upcase)
      image_list.each do |image_hash|
        get_products_per_image_hash(style, image_hash).each do |product|
          image_class = get_image_class_for_image_hash(image_hash)
          next if image_class.nil?
          path = image_hash[:path]
          public_url = "https://staging.bellroy.it#{Dragonfly.app.fetch_file(Rails.root + path).url}"
          rows << [product.sku, image_hash[:currency_code], public_url, image_class]
        end
      end
    end
  end
end
generate_images_csv
UploadImages::EnqueueUploadImagesJob
UploadImages::EnqueueUploadImagesJob.perform
UploadImages::EnqueueUploadImagesJob.new.perform
exit
UploadImages::EnqueueUploadImagesJob.new.perform
UploadImages::UploadImage
exit
continue
exit
next'
next
row
row.sku
row[:sku]
row["sk"]]
row["sku"]
exit
continue
a = open(https://staging.bellroy.it/dynamic-assets/W1siZmYiLCIvc3J2L3d3dy9iZWxscm95LXN0YWdpbmcvcmVsZWFzZXMvMjAxNzAzMDgwNTMyMDEvYXBwL2Fzc2V0cy9pbWFnZXMvcHJvZHVjdC93aHNkL3Byb2R1Y3RfZ2FsbGVyeS9ibGFjay9sb19faGkvY3VycmVuY2llcy91c2QvNF9iZWxscm95LXdoc2QtYmxhY2stdXNkLWJlbGxyb3l3ZWJzaXRlLTAyLmpwZyJdXQ/bbc0f36d86214d20/4_bellroy-whsd-black-usd-bellroywebsite-02.jpg)
a = open("https://staging.bellroy.it/dynamic-assets/W1siZmYiLCIvc3J2L3d3dy9iZWxscm95LXN0YWdpbmcvcmVsZWFzZXMvMjAxNzAzMDgwNTMyMDEvYXBwL2Fzc2V0cy9pbWFnZXMvcHJvZHVjdC93aHNkL3Byb2R1Y3RfZ2FsbGVyeS9ibGFjay9sb19faGkvY3VycmVuY2llcy91c2QvNF9iZWxscm95LXdoc2QtYmxhY2stdXNkLWJlbGxyb3l3ZWJzaXRlLTAyLmpwZyJdXQ/bbc0f36d86214d20/4_bellroy-whsd-black-usd-bellroywebsite-02.jpg")
require "open-uri"
a = open("https://staging.bellroy.it/dynamic-assets/W1siZmYiLCIvc3J2L3d3dy9iZWxscm95LXN0YWdpbmcvcmVsZWFzZXMvMjAxNzAzMDgwNTMyMDEvYXBwL2Fzc2V0cy9pbWFnZXMvcHJvZHVjdC93aHNkL3Byb2R1Y3RfZ2FsbGVyeS9ibGFjay9sb19faGkvY3VycmVuY2llcy91c2QvNF9iZWxscm95LXdoc2QtYmxhY2stdXNkLWJlbGxyb3l3ZWJzaXRlLTAyLmpwZyJdXQ/bbc0f36d86214d20/4_bellroy-whsd-black-usd-bellroywebsite-02.jpg")
a.class
exit
dirname
dirname = File.dirname(Rails.root.join('tmp').to_s + '/temp_product_images')
dirname
Rails.root.join('tmp').to_s + '/temp_product_images'
def get_products_per_image_hash(style, image_hash)
  variant_name = image_hash[:variant_name]
  return style.send(:products) if variant_name.blank?
  variants = variant_name.split('__')
  products = variants.flat_map do |variant|
    style.variants.find { |v| v.name == variant }.products
  end.reject(&:disabled?)
  if image_hash[:color].present?
    products.select! { |product| product.color == image_hash[:color] }
  end
  products
end
def get_image_class_for_image_hash(image_hash)
  case image_hash[:group]
  when 'product_explode'
    'BellroyDotCom::ProductExplodeImage'
  when 'product_gallery'
    'BellroyDotCom::GalleryImage'
  when 'product_sketch'
    'BellroyDotCom::ProductSketchImage'
  when 'product_slider'
    'BellroyDotCom::LifestyleSliderImage'
  when 'range'
    'BellroyDotCom::RangePageImage'
  when 'range_exploded_hovers'
    'BellroyDotCom::RangePageExplodeImage'
  when 'product_gallery_video_preview'
    'BellroyDotCom::ProductPageVideoImage'
  when 'nude_approach'
    nil
  else
    raise "Couldn't find the appropriate image role. #{image_hash[:group]}"
  end
end
def generate_images_csv
  CSV.open("tmp/images.csv", "wb") do |rows|
    rows << ['sku', 'currency_code', 'path', 'class']
    image_manifest = Product::ImageManifest.instance
    manifests = image_manifest.send(:manifests)
    manifests.each do |style_code, image_list|
      style = ProductQuery.find_style_by_code(style_code.upcase)
      image_list.sort_by{ |image_hash| image_hash[:path] }.each do |image_hash|
        get_products_per_image_hash(style, image_hash).each do |product|
          image_class = get_image_class_for_image_hash(image_hash)
          next if image_class.nil?
          path = image_hash[:path]
          public_url = "https://staging.bellroy.it#{Dragonfly.app.fetch_file(Rails.root + path).url}"
          rows << [product.sku, image_hash[:currency_code], public_url, image_class]
        end
      end
    end
  end
end
generate_images_csv
exit
csv
csv,count
csv.count
csv.last
csv.first
next
exit
continue
row
row['sku']
UploadImages::UploadImageJob
UploadImages::UploadImageJob.perform_async(
  row['sku'], row['currency_code'], row['path'], row['class'], row['sort_order']
)
continue
row
exit
query
InvoiceToSequenceNumberMap.count
InvoiceToSequenceNumberMap.count.last
InvoiceToSequenceNumberMap.last
exit
query
InvoiceToSequenceNumberMap
InvoiceToSequenceNumberMap.last
next
mapping
next
@invoice_number
exit
query
exit
query
exit
query
exit
query
next
mapping
InvoiceToSequenceNumberMap.last
exit
Raw::Saasu::InvoiceListItem
::Raw::Saasu::InvoiceListItem
::Raw::Saasu::InvoiceListItem.last
exit
continue
exit
@invoice_number
exit
Raw::Saasu::InvoiceListItem.last
:Raw::Saasu::InvoiceListItem.last
::Raw::Saasu::InvoiceListItem.last
::Raw::Saasu::InvoiceListItem
exit
invoice
invoice.invoice_uid
invoice
::Saasu::Helpers.saasu_invoice_url(invoice.invoice_uid)
mapping
exit
search_pattern
matching_sequence_number(pattern: search_pattern)
InvoiceToSequenceNumberMap
InvoiceToSequenceNumberMap.count
invoice
next
exit
@invoice_number
@invoice_number =~ /\A6\d{7}\z/
next
@invoice
@invoice.invoice_number
n
invoice
next
exit
@invoice_number
exit
mapping
exit
next
invoice
exit
@lookup
exit
step
ship_to_from_notes?
address_from_notes[6]
address_from_notes
step
continue
next
invalid_legacy_address_notes_format?
invalid_notes_header?
next
notes
transformed_notes
legacy_notes_header?
next
source_string
next
lines
next
lines
source_string
source_string.split('\n')
source_string.split("\n")
source_string.split("\\n")
source_string.split('\n')
exit
invoice
exit
invoice
exit
continute
c
n
CONTACT_DETAILS
n
continue
CONTACT_DETAILS
exit
invoice.total_tax_amount
invoice.total_tax_amount.class
format(invoice.total_tax_amount)
format(invoice.total_tax_amount.to_s)
exit
price
Kernel.format('%.2f', (price || '0.0000').to_f.round(2))
continue
price
Kernel.format('%.2f', (price || '0.0000').to_f.round(2))
continue
n
exit
next
saasu_file_uid
next
invoice_uid
exit
next
step
continue
step
continue
step
exit
invoice_number
saasu_file_uid
next
result
Raw::Bellroy
Raw::Bellroy::InvoiceListItem
Raw::Saasu::InvoiceListItem
Raw::Saasu::InvoiceListItem.last
Raw::Saasu::InvoiceListItem.last.count
exit
next
result
Raw::Saasu::InvoiceListItem.count
result
exit
saasu_file_uid
invoice_number
exit
shipping_address
billing_address
next
page
next
page
exit
Haml::Engine.new(template).render(self, locals)
Haml::Engine.new(template).render(self, locals).to_json
Haml::Engine.new(template).render(self, locals).to_json.html_safe
Haml::Engine.new(template).render(self, locals).html_safe
Haml::Engine.new(template).render(self, locals).html_safe.to_json
Haml::Engine.new(template).render(self, locals)
Haml::Engine.new(template).render(self, locals).to_json
Haml::Engine.new(template).render(self, locals).to_json.html_safe
Haml::Engine.new(template).render(self, locals).html_safe.to_json
raw Haml::Engine.new(template).render(self, locals).to_json
Haml::Engine.new(template).render(self, locals).html_safe.as_json
exit
Haml::Engine.new(template).render(self, locals)
Haml::Engine.new(template).render(self, locals).to_json
Haml::Engine.new(template).render(self, locals).to_json.as_json
Haml::Engine.new(template).render(self, locals).to_json.html_safe
exit
body
body_json
loader = Freshdesk::CustomerInfoLoader.new(ticket_id, contact_id)
customer_info = Freshdesk::CustomerInfoLoader.new(ticket_id, contact_id).customer_info
customer_info
exit
contact
exit
contact
exit
contact
contact.user
contact['user']
contact
puts contact
p contact
contact.class
contact
contact.methods
cpntact.to_json
contact.to_json
contact.attributes[:user][:email]
contact.attributes[:user][:name]
next
@customer_info ||= CustomerInfo.new(contact.attributes[:user][:email], contact.attributes[:user][:name])
@customer_info
next
customer_info
next
content
customer_info
next
Freshdesk::CustomerInfoLoader.new(ticket_id, contact_id).customer_info
exit
contact
contact.to_json
next
customer_info
next
content
exit
next
invoice_uid
Raw::Saasu::InvoiceListItem.last
saasu_file_uid
order.name
country_codes
exit
country_codes
exit
country_code
country_codes
exit
country_codes
step
country_codes
next
e
country_codes = [:bad_country_code]
country_codes.all? { |country_code| country_code =~ /\A[A-Z]{2}\z/
}
exit
EXIT
exit
currency
step
next
n
xit
exit
OrderLineItem
OrderLineItem.last
LogisticsOrderSerializer.new(Order.find(55213)).to_json
o = Order.find(55213)
o.order_line_items
o.order_line_items.first
o.order_line_items.first.description
o.order_line_items.map(&:description)
o.order_line_items.first
def doit
  order_line_items = []
  OrderLineItem.all each do |order_line_item|
    begin
      order_line_item.description
    rescue OrderLineItemProductSKUError => exception
      order_line_items << order_line_item
      puts "Line item: #{order_line_item.id}, Order: #{order_line_item.order.id}, Sku: #{order_line_item.product_sku}"
    end
  end
  order_line_items.group_by(&:product_sku)
end
doit
def doit
  order_line_items = []
  OrderLineItem.all.each do |order_line_item|
    begin
      order_line_item.description
    rescue OrderLineItemProductSKUError => exception
      order_line_items << order_line_item
      puts "Line item: #{order_line_item.id}, Order: #{order_line_item.order.id}, Sku: #{order_line_item.product_sku}"
    end
  end
  order_line_items.group_by(&:product_sku)
end
doit
def doit
  order_line_items = []
  OrderLineItem.all.each do |order_line_item|
    begin
      order_line_item.description
    rescue OrderLineItem::ProductSKUError => exception
      order_line_items << order_line_item
      puts "Line item: #{order_line_item.id}, Order: #{order_line_item.order.id}, Sku: #{order_line_item.product_sku}"
    end
  end
  order_line_items.group_by(&:product_sku)
def doit
  order_line_items = []
  OrderLineItem.all.each do |order_line_item|
    begin
      order_line_item.description
    rescue OrderLineItem::ProductSKUError => exception
      order_line_items << order_line_item
      puts "Line item: #{order_line_item.id}, Order: #{order_line_item.order.id}, Sku: #{order_line_item.product_sku}"
    end
  end
  order_line_items.group_by(&:product_sku)
end
doit
def doit
  order_line_items = []
  message = ''
  OrderLineItem.all.each do |order_line_item|
    begin
      order_line_item.description
    rescue OrderLineItem::UnknownProductSKUError => exception
      order_line_items << order_line_item
      message += "Line item: #{order_line_item.id}, Order: #{order_line_item.order.id}, Sku: #{order_line_item.product_sku}"
    end
  end
  order_line_items.group_by(&:product_sku)
end
doit
OrderLineItem.last
OrderLineItem.last.id
OrderLineItem.last.order
OrderLineItem.last.order.id
def doit
  order_line_items = []
  message = ''
  OrderLineItem.all.each do |order_line_item|
    begin
      order_line_item.description
    rescue OrderLineItem::UnknownProductSKUError => exception
      order_line_items << order_line_item
      message += "Line item: #{order_line_item.id}, Order: #{order_line_item.order.id}, Sku: #{order_line_item.product_sku}"
    end
  end
  order_line_items.group_by(&:product_sku)
end
doit
def doit
  order_line_items = []
  message = ''
  OrderLineItem.all.each do |order_line_item|
    begin
      order_line_item.description
    rescue OrderLineItem::UnknownProductSKUError => exception
      order_line_items << order_line_item
      message += "Line item: #{order_line_item.id}, Order: #{order_line_item.order.id}, Sku: #{order_line_item.product_sku}"
    rescue StandardError => bang
      print "Error running script: " + bang
    end
  end
  order_line_items.group_by(&:product_sku)
end
doit
def doit
  order_line_items = []
  message = ''
  OrderLineItem.all.each do |order_line_item|
    begin
      order_line_item.description
    rescue OrderLineItem::UnknownProductSKUError => exception
      order_line_items << order_line_item
      message += "Line item: #{order_line_item.id}, Order: #{order_line_item.order.id}, Sku: #{order_line_item.product_sku}"
    rescue StandardError => bang
      print "Error running script: " + bang
    end
  end
  order_line_items.group_by(&:product_sku)
end
doit
def doit
  order_line_items = []
  message = ''
  OrderLineItem.all.each do |order_line_item|
    begin
      order_line_item.description
    rescue OrderLineItem::UnknownProductSKUError => exception
      order_line_items << order_line_item
      message += "Line item: #{order_line_item.id}, Order: #{order_line_item.order.id}, Sku: #{order_line_item.product_sku}"
    rescue StandardError => bang
      print "Error running script: " + bang.message
    end
  end
  order_line_items.group_by(&:product_sku)
end
doit
def doit
  order_line_items = []
  message = ''
  OrderLineItem.all.each do |order_line_item|
    begin
      order_line_item.description
    rescue OrderLineItem::UnknownProductSKUError => exception
      order_line_items << order_line_item
      message += "Line item: #{order_line_item.id}, Order: #{order_line_item.order.id}, Sku: #{order_line_item.product_sku}"
    rescue StandardError => bang
      print "Error running script: " + bang.message
    end
  end
  order_line_items.group_by(&:product_sku)
end
doit
def doit
  order_line_items = []
  message = ''
  OrderLineItem.all.each do |order_line_item|
    begin
      order_line_item.description
    rescue OrderLineItem::UnknownProductSKUError => exception
      order_line_items << order_line_item
      message += "Line item: #{order_line_item.id}, Order: #{order_line_item.order.id}, Sku: #{order_line_item.product_sku}"
    rescue StandardError => bang
      print "Error running script: " + bang.message
    end
  end
  print message
  order_line_items.group_by(&:product_sku)
end
doit
def doit
  order_line_items = []
  message = ''
  OrderLineItem.all.each do |order_line_item|
    begin
      order_line_item.description
    rescue OrderLineItem::UnknownProductSKUError => exception
      order_line_items << order_line_item
      message += "Line item: #{order_line_item.id}, Order: #{order_line_item.order.id}, Sku: #{order_line_item.product_sku}"
    rescue StandardError => bang
      print "Error running script: " + bang.message
    end
  end
  print message
  order_line_items.group_by(&:product_sku)
def doit
  order_line_items = []
  message = ''
  OrderLineItem.last(500).each do |order_line_item|
    begin
      order_line_item.description
    rescue OrderLineItem::UnknownProductSKUError => exception
      order_line_items << order_line_item
      message += "Line item: #{order_line_item.id}, Order: #{order_line_item.order.id}, Sku: #{order_line_item.product_sku}"
    rescue StandardError => bang
      print "Error running script: " + bang.message
    end
  end
  print message
  order_line_items.group_by(&:product_sku)
end
doit
def doit
  order_line_items = []
  message = ''
  OrderLineItem.last(500).each do |order_line_item|
    begin
      order_line_item.description
    rescue OrderLineItem::UnknownProductSKUError => exception
      order_line_items << order_line_item
      message += "Line item: #{order_line_item.id}, Order: #{order_line_item.order.id}, Sku: #{order_line_item.product_sku}"
    rescue StandardError => bang
      print "Error running script: " + bang.message
    end
  end
  print message
  order_line_items.group_by(&:product_sku)
end
doit
def doit
  order_line_items = []
  message = ''
  OrderLineItem.last(500).each do |order_line_item|
    begin
      order_line_item.description
    rescue OrderLineItem::UnknownProductSKUError => exception
      order_line_items << order_line_item
      message += "Line item: #{order_line_item.id}, Order: #{order_line_item.order.id}, Sku: #{order_line_item.product_sku}"
    rescue StandardError => bang
      print "Error running script: " + bang.message
    end
  end
  print message
  order_line_items.group_by(&:product_sku)
end
doit
def doit
  order_line_items = []
  message = ''
  OrderLineItem.last(500).each do |order_line_item|
    begin
      order_line_item.description
    rescue OrderLineItem::UnknownProductSKUError => exception
      order_line_items << order_line_item
      message += "Line item: #{order_line_item.id}, Order: #{order_line_item.order.id}, Sku: #{order_line_item.product_sku}"
    rescue StandardError => bang
      print "Error running script: " + bang.message
    end
  end
  print message
  order_line_items.group_by(&:product_sku)
end
doit
def doit
  order_line_items = []
  message = ''
  count = 0
  OrderLineItem.last(10).each do |order_line_item|
    puts "Count #{count}"
    begin
      order_line_item.description
    rescue OrderLineItem::UnknownProductSKUError => exception
      order_line_items << order_line_item
      message += "Line item: #{order_line_item.id}, Order: #{order_line_item.order_id}, Sku: #{order_line_item.product_sku}"
    rescue StandardError => bang
      print "Error running script: " + bang.message
    end
    count += 1
  end
  print message
  order_line_items.group_by(&:product_sku)
end
doit
def doit
  order_line_items = []
  message = ''
  count = 0
  OrderLineItem.last(20).each do |order_line_item|
    puts "Count #{count}"
    begin
      order_line_item.description
    rescue OrderLineItem::UnknownProductSKUError => exception
      order_line_items << order_line_item
      message += "Line item: #{order_line_item.id}, Order: #{order_line_item.order_id}, Sku: #{order_line_item.product_sku}"
    rescue StandardError => bang
      print "Error running script: " + bang.message
    end
    count += 1
  end
  print message
  order_line_items.group_by(&:product_sku)
end
doit
def doit
  ActiveRecord::Base.logger = nil
  order_line_items = []
  message = ''
  count = 0
  OrderLineItem.all.each do |order_line_item|
    puts "Count #{count}"
    begin
      order_line_item.description
    rescue OrderLineItem::UnknownProductSKUError => exception
      order_line_items << [order_line_item.id, order_line_item.product_sku]
      message += "Line item: #{order_line_item.id}, Order: #{order_line_item.order_id}, Sku: #{order_line_item.product_sku}"
    rescue StandardError => bang
      print "Error running script: " + bang.message
    end
    count += 1
  end
  print message
  order_line_items.group_by { |order_line_item| order_line_item[1] }
end
doit
def doit
  ActiveRecord::Base.logger = nil
  order_line_items = []
  message = ''
  count = 0
  OrderLineItem.all.each do |order_line_item|
    puts "Count #{count}"
    begin
      order_line_item.description
    rescue OrderLineItem::UnknownProductSKUError => exception
      order_line_items << [order_line_item.id, order_line_item.product_sku]
      message += "Line item: #{order_line_item.id}, Order: #{order_line_item.order_id}, Sku: #{order_line_item.product_sku}"
    rescue StandardError => bang
      print "Error running script: " + bang.message
    end
    count += 1
  end
  print message
  order_line_items.group_by { |order_line_item| order_line_item[1] }
end
doit
groups = _
groups.first
groups.count
groups.each{ |group| group.first.last }
groups.keys
groups.keys.sort
OrderLineItem
OrderLineItem.last
skus = ["ENCA-BLACK",
  "ENCA-BLUESTEEL",
  "ENCA-CARAMEL",
  "ENCA-EUCALYPTUS",
  "ENCA-JAVA",
  "PCIA-BLACK",
  "PCIA-BLUESTEEL",
  "PCIA-CHARCOAL",
  "PCIA-JAVA",
  "PCIA-TAMARILLO",
  "PCIB-BLACK",
  "PCIB-BLUESTEEL",
  "PCIB-CHARCOAL",
  "PCIB-JAVA",
  "PCIB-TAMARILLO",
  "PCIC-BLACK",
  "PCIC-BLUESTEEL",
  "PCIC-CHARCOAL",
  "PCIC-JAVA",
  "PCIC-TAMARILLO",
  "PCID-BLACK",
  "PCID-BLUESTEEL",
  "PCID-CHARCOAL",
  "PCID-JAVA",
  "PCID-TAMARILLO",
  "PCIE-BLACK",
  "PCIE-BLUESTEEL",
  "PCIE-CHARCOAL",
  "PCIE-JAVA",
  "PCIE-TAMARILLO",
  "PCPA-BLACK",
  "PCPA-BLUESTEEL",
  "PCPA-CHARCOAL",
  "PCPA-JAVA",
  "PCPA-TAMARILLO",
  "PCPB-BLACK",
  "PCPB-BLUESTEEL",
  "PCPB-CHARCOAL",
  "PCPB-JAVA",
  "PCPB-TAMARILLO",
  "PCPC-BLACK",
  "PCPC-BLUESTEEL",
  "PCPC-CHARCOAL",
  "PCPC-JAVA",
  "PCPC-TAMARILLO",
  "PCPD-BLACK",
  "PCPD-BLUESTEEL",
  "PCPD-CHARCOAL",
  "PCPD-JAVA",
  "PCPD-TAMARILLO",
  "PCPE-BLACK",
  "PCPE-BLUESTEEL",
  "PCPE-CHARCOAL",
  "PCPE-JAVA",
  "PCPE-TAMARILLO",
  "WCFA-BLACK",
  "WCFA-BLUESTEEL",
  "WCFA-JAVA",
  "WCFA-TAMARILLO",
  "WCFB-BLACK",
  "WCFB-BLUESTEEL",
  "WCFB-JAVA",
  "WCFB-TAMARILLO",
  "WEDA-BLACK",
  "WEDA-COGNAC",
  "WEDA-SLATE",
  "WEDB-BLACK",
  "WEDB-COGNAC",
  "WEDB-SLATE",
  "WHSD-BLACK",
  "WHSD-BLACK-RFID",
  "WHSD-CARAMEL-RFID",
  "WHSD-CHARCOAL",
  "WHSD-CHARCOALARB",
  "WHSD-COCOA",
  "WHSD-COGNAC",
  "WHSD-JAVA",
  "WHSD-JAVA-RFID",
  "WHSD-SLATE",
  "WHSE-BLACK",
  "WHSE-BLACK-RFID",
  "WHSE-CARAMEL-RFID",
  "WHSE-CHARCOAL",
  "WHSE-CHARCOALARB",
  "WHSE-COCOA",
  "WHSE-COGNAC",
  "WHSE-JAVA",
  "WHSE-JAVA-RFID",
  "WHSE-SLATE",
  "WNSC-ARCTICBLUE",
  "WNSC-BLACK",
  "WNSC-BLUESTEEL",
  "WNSC-BURNTORANGE",
  "WNSC-CHARCOAL",
  "WNSC-COCOA",
  "WNSC-JAVA",
  "WNSC-TEAL",
  "WPSA-BLACK",
  "WPSA-CHARCOAL",
  "WPSA-MOCHA",
  "WPSA-TAN",
  "WTRA-CHARCOAL",
  "WTRA-COCOA",
  "WTRA-MIDNIGHT",
  "WTRA-MOCHA",
"WTRA-SLATE"]
skus = ["ENCA-BLACK",
  "ENCA-BLUESTEEL",
  "ENCA-CARAMEL",
  "ENCA-EUCALYPTUS",
  "ENCA-JAVA",
  "PCIA-BLACK",
  "PCIA-BLUESTEEL",
  "PCIA-CHARCOAL",
  "PCIA-JAVA",
  "PCIA-TAMARILLO",
  "PCIB-BLACK",
  "PCIB-BLUESTEEL",
  "PCIB-CHARCOAL",
  "PCIB-JAVA",
  "PCIB-TAMARILLO",
  "PCIC-BLACK",
  "PCIC-BLUESTEEL",
  "PCIC-CHARCOAL",
  "PCIC-JAVA",
  "PCIC-TAMARILLO",
  "PCID-BLACK",
  "PCID-BLUESTEEL",
  "PCID-CHARCOAL",
  "PCID-JAVA",
  "PCID-TAMARILLO",
  "PCIE-BLACK",
  "PCIE-BLUESTEEL",
  "PCIE-CHARCOAL",
  "PCIE-JAVA",
  "PCIE-TAMARILLO",
  "PCPA-BLACK",
  "PCPA-BLUESTEEL",
  "PCPA-CHARCOAL",
  "PCPA-JAVA",
  "PCPA-TAMARILLO",
  "PCPB-BLACK",
  "PCPB-BLUESTEEL",
  "PCPB-CHARCOAL",
  "PCPB-JAVA",
  "PCPB-TAMARILLO",
  "PCPC-BLACK",
  "PCPC-BLUESTEEL",
  "PCPC-CHARCOAL",
  "PCPC-JAVA",
  "PCPC-TAMARILLO",
  "PCPD-BLACK",
  "PCPD-BLUESTEEL",
  "PCPD-CHARCOAL",
  "PCPD-JAVA",
  "PCPD-TAMARILLO",
  "PCPE-BLACK",
  "PCPE-BLUESTEEL",
  "PCPE-CHARCOAL",
  "PCPE-JAVA",
  "PCPE-TAMARILLO",
  "WCFA-BLACK",
  "WCFA-BLUESTEEL",
  "WCFA-JAVA",
  "WCFA-TAMARILLO",
  "WCFB-BLACK",
  "WCFB-BLUESTEEL",
  "WCFB-JAVA",
  "WCFB-TAMARILLO",
  "WEDA-BLACK",
  "WEDA-COGNAC",
  "WEDA-SLATE",
  "WEDB-BLACK",
  "WEDB-COGNAC",
  "WEDB-SLATE",
  "WHSD-BLACK",
  "WHSD-BLACK-RFID",
  "WHSD-CARAMEL-RFID",
  "WHSD-CHARCOAL",
  "WHSD-CHARCOALARB",
  "WHSD-COCOA",
  "WHSD-COGNAC",
  "WHSD-JAVA",
  "WHSD-JAVA-RFID",
  "WHSD-SLATE",
  "WHSE-BLACK",
  "WHSE-BLACK-RFID",
  "WHSE-CARAMEL-RFID",
  "WHSE-CHARCOAL",
  "WHSE-CHARCOALARB",
  "WHSE-COCOA",
  "WHSE-COGNAC",
  "WHSE-JAVA",
  "WHSE-JAVA-RFID",
  "WHSE-SLATE",
  "WNSC-ARCTICBLUE",
  "WNSC-BLACK",
  "WNSC-BLUESTEEL",
  "WNSC-BURNTORANGE",
  "WNSC-CHARCOAL",
  "WNSC-COCOA",
  "WNSC-JAVA",
  "WNSC-TEAL",
  "WPSA-BLACK",
  "WPSA-CHARCOAL",
  "WPSA-MOCHA",
  "WPSA-TAN",
  "WTRA-CHARCOAL",
  "WTRA-COCOA",
  "WTRA-MIDNIGHT",
  "WTRA-MOCHA",
"WTRA-SLATE"]
skus = ["ENCA-BLACK",
  "ENCA-BLUESTEEL",
  "ENCA-CARAMEL",
  "ENCA-EUCALYPTUS",
  "ENCA-JAVA",
  "PCIA-BLACK",
  "PCIA-BLUESTEEL",
  "PCIA-CHARCOAL",
  "PCIA-JAVA",
  "PCIA-TAMARILLO",
  "PCIB-BLACK",
  "PCIB-BLUESTEEL",
  "PCIB-CHARCOAL",
  "PCIB-JAVA",
  "PCIB-TAMARILLO",
  "PCIC-BLACK",
  "PCIC-BLUESTEEL",
  "PCIC-CHARCOAL",
  "PCIC-JAVA",
  "PCIC-TAMARILLO",
  "PCID-BLACK",
  "PCID-BLUESTEEL",
  "PCID-CHARCOAL",
  "PCID-JAVA",
  "PCID-TAMARILLO",
  "PCIE-BLACK",
  "PCIE-BLUESTEEL",
  "PCIE-CHARCOAL",
  "PCIE-JAVA",
  "PCIE-TAMARILLO",
  "PCPA-BLACK",
  "PCPA-BLUESTEEL",
  "PCPA-CHARCOAL",
  "PCPA-JAVA",
  "PCPA-TAMARILLO",
  "PCPB-BLACK",
  "PCPB-BLUESTEEL",
  "PCPB-CHARCOAL",
  "PCPB-JAVA",
  "PCPB-TAMARILLO",
  "PCPC-BLACK",
  "PCPC-BLUESTEEL",
  "PCPC-CHARCOAL",
  "PCPC-JAVA",
  "PCPC-TAMARILLO",
  "PCPD-BLACK",
  "PCPD-BLUESTEEL",
  "PCPD-CHARCOAL",
  "PCPD-JAVA",
  "PCPD-TAMARILLO",
  "PCPE-BLACK",
  "PCPE-BLUESTEEL",
  "PCPE-CHARCOAL",
  "PCPE-JAVA",
  "PCPE-TAMARILLO",
  "WCFA-BLACK",
  "WCFA-BLUESTEEL",
  "WCFA-JAVA",
  "WCFA-TAMARILLO",
  "WCFB-BLACK",
  "WCFB-BLUESTEEL",
  "WCFB-JAVA",
  "WCFB-TAMARILLO",
  "WEDA-BLACK",
  "WEDA-COGNAC",
  "WEDA-SLATE",
  "WEDB-BLACK",
  "WEDB-COGNAC",
  "WEDB-SLATE",
  "WHSD-BLACK",
  "WHSD-BLACK-RFID",
  "WHSD-CARAMEL-RFID",
  "WHSD-CHARCOAL",
  "WHSD-CHARCOALARB",
  "WHSD-COCOA",
  "WHSD-COGNAC",
  "WHSD-JAVA",
  "WHSD-JAVA-RFID",
  "WHSD-SLATE",
  "WHSE-BLACK",
  "WHSE-BLACK-RFID",
  "WHSE-CARAMEL-RFID",
  "WHSE-CHARCOAL",
  "WHSE-CHARCOALARB",
  "WHSE-COCOA",
  "WHSE-COGNAC",
  "WHSE-JAVA",
  "WHSE-JAVA-RFID",
  "WHSE-SLATE",
  "WNSC-ARCTICBLUE",
  "WNSC-BLACK",
  "WNSC-BLUESTEEL",
  "WNSC-BURNTORANGE",
  "WNSC-CHARCOAL",
  "WNSC-COCOA",
  "WNSC-JAVA",
  "WNSC-TEAL",
  "WPSA-BLACK",
  "WPSA-CHARCOAL",
  "WPSA-MOCHA",
  "WPSA-TAN",
  "WTRA-CHARCOAL",
  "WTRA-COCOA",
  "WTRA-MIDNIGHT",
  "WTRA-MOCHA",
"WTRA-SLATE"]
mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi' }
mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi' } OrderLineItem.where(product_sku: skus) do |order_line_item|
variant = order_line_item.variant_name
puts "#{order_line_item.sku}\t#{variant}\t#{mapping[variant]}"
end
OrderLineItem.where(product_sku: skus).all do |order_line_item|
  variant = order_line_item.variant_name
  puts "#{order_line_item.sku}\t#{variant}\t#{mapping[variant]}"
end
s = ''
OrderLineItem.where(product_sku: skus).all do |order_line_item|
  variant = order_line_item.variant_name
  s += s "#{order_line_item.sku}\t#{variant}\t#{mapping[variant]}\n"
end
s = ''
OrderLineItem.where(product_sku: skus).all do |order_line_item|
  variant = order_line_item.variant_name
  s += s "#{order_line_item.sku}\t#{variant}\t#{mapping[variant]}\n"
end s = ''
OrderLineItem.where(product_sku: skus).all do |order_line_item|
  variant = order_line_item.variant_name
  s += "#{order_line_item.sku}\t#{variant}\t#{mapping[variant]}\n"
end
s = ''
OrderLineItem.where(product_sku: skus).all do |order_line_item|
  variant = order_line_item.variant_name
  s += "#{order_line_item.sku}\t#{variant}\t#{mapping[variant]}\n"
end
skus = ["ENCA-BLACK",
  "ENCA-BLUESTEEL",
  "ENCA-CARAMEL",
  "ENCA-EUCALYPTUS",
  "ENCA-JAVA",
  "PCIA-BLACK",
  "PCIA-BLUESTEEL",
  "PCIA-CHARCOAL",
  "PCIA-JAVA",
  "PCIA-TAMARILLO",
  "PCIB-BLACK",
  "PCIB-BLUESTEEL",
  "PCIB-CHARCOAL",
  "PCIB-JAVA",
  "PCIB-TAMARILLO",
  "PCIC-BLACK",
  "PCIC-BLUESTEEL",
  "PCIC-CHARCOAL",
  "PCIC-JAVA",
  "PCIC-TAMARILLO",
  "PCID-BLACK",
  "PCID-BLUESTEEL",
  "PCID-CHARCOAL",
  "PCID-JAVA",
  "PCID-TAMARILLO",
  "PCIE-BLACK",
  "PCIE-BLUESTEEL",
  "PCIE-CHARCOAL",
  "PCIE-JAVA",
  "PCIE-TAMARILLO",
  "PCPA-BLACK",
  "PCPA-BLUESTEEL",
  "PCPA-CHARCOAL",
  "PCPA-JAVA",
  "PCPA-TAMARILLO",
  "PCPB-BLACK",
  "PCPB-BLUESTEEL",
  "PCPB-CHARCOAL",
  "PCPB-JAVA",
  "PCPB-TAMARILLO",
  "PCPC-BLACK",
  "PCPC-BLUESTEEL",
  "PCPC-CHARCOAL",
  "PCPC-JAVA",
  "PCPC-TAMARILLO",
  "PCPD-BLACK",
  "PCPD-BLUESTEEL",
  "PCPD-CHARCOAL",
  "PCPD-JAVA",
  "PCPD-TAMARILLO",
  "PCPE-BLACK",
  "PCPE-BLUESTEEL",
  "PCPE-CHARCOAL",
  "PCPE-JAVA",
  "PCPE-TAMARILLO",
  "WCFA-BLACK",
  "WCFA-BLUESTEEL",
  "WCFA-JAVA",
  "WCFA-TAMARILLO",
  "WCFB-BLACK",
  "WCFB-BLUESTEEL",
  "WCFB-JAVA",
  "WCFB-TAMARILLO",
  "WEDA-BLACK",
  "WEDA-COGNAC",
  "WEDA-SLATE",
  "WEDB-BLACK",
  "WEDB-COGNAC",
  "WEDB-SLATE",
  "WHSD-BLACK",
  "WHSD-BLACK-RFID",
  "WHSD-CARAMEL-RFID",
  "WHSD-CHARCOAL",
  "WHSD-CHARCOALARB",
  "WHSD-COCOA",
  "WHSD-COGNAC",
  "WHSD-JAVA",
  "WHSD-JAVA-RFID",
  "WHSD-SLATE",
  "WHSE-BLACK",
  "WHSE-BLACK-RFID",
  "WHSE-CARAMEL-RFID",
  "WHSE-CHARCOAL",
  "WHSE-CHARCOALARB",
  "WHSE-COCOA",
  "WHSE-COGNAC",
  "WHSE-JAVA",
  "WHSE-JAVA-RFID",
  "WHSE-SLATE",
  "WNSC-ARCTICBLUE",
  "WNSC-BLACK",
  "WNSC-BLUESTEEL",
  "WNSC-BURNTORANGE",
  "WNSC-CHARCOAL",
  "WNSC-COCOA",
  "WNSC-JAVA",
  "WNSC-TEAL",
  "WPSA-BLACK",
  "WPSA-CHARCOAL",
  "WPSA-MOCHA",
  "WPSA-TAN",
  "WTRA-CHARCOAL",
  "WTRA-COCOA",
  "WTRA-MIDNIGHT",
  "WTRA-MOCHA",
"WTRA-SLATE"]
s
skus = ["ENCA-BLACK",
  "ENCA-BLUESTEEL",
  "ENCA-CARAMEL",
  "ENCA-EUCALYPTUS",
  "ENCA-JAVA",
  "PCIA-BLACK",
  "PCIA-BLUESTEEL",
  "PCIA-CHARCOAL",
  "PCIA-JAVA",
  "PCIA-TAMARILLO",
  "PCIB-BLACK",
  "PCIB-BLUESTEEL",
  "PCIB-CHARCOAL",
  "PCIB-JAVA",
  "PCIB-TAMARILLO",
  "PCIC-BLACK",
  "PCIC-BLUESTEEL",
  "PCIC-CHARCOAL",
  "PCIC-JAVA",
  "PCIC-TAMARILLO",
  "PCID-BLACK",
  "PCID-BLUESTEEL",
  "PCID-CHARCOAL",
  "PCID-JAVA",
  "PCID-TAMARILLO",
  "PCIE-BLACK",
  "PCIE-BLUESTEEL",
  "PCIE-CHARCOAL",
  "PCIE-JAVA",
  "PCIE-TAMARILLO",
  "PCPA-BLACK",
  "PCPA-BLUESTEEL",
  "PCPA-CHARCOAL",
  "PCPA-JAVA",
  "PCPA-TAMARILLO",
  "PCPB-BLACK",
  "PCPB-BLUESTEEL",
  "PCPB-CHARCOAL",
  "PCPB-JAVA",
  "PCPB-TAMARILLO",
  "PCPC-BLACK",
  "PCPC-BLUESTEEL",
  "PCPC-CHARCOAL",
  "PCPC-JAVA",
  "PCPC-TAMARILLO",
  "PCPD-BLACK",
  "PCPD-BLUESTEEL",
  "PCPD-CHARCOAL",
  "PCPD-JAVA",
  "PCPD-TAMARILLO",
  "PCPE-BLACK",
  "PCPE-BLUESTEEL",
  "PCPE-CHARCOAL",
  "PCPE-JAVA",
  "PCPE-TAMARILLO",
  "WCFA-BLACK",
  "WCFA-BLUESTEEL",
  "WCFA-JAVA",
  "WCFA-TAMARILLO",
  "WCFB-BLACK",
  "WCFB-BLUESTEEL",
  "WCFB-JAVA",
  "WCFB-TAMARILLO",
  "WEDA-BLACK",
  "WEDA-COGNAC",
  "WEDA-SLATE",
  "WEDB-BLACK",
  "WEDB-COGNAC",
  "WEDB-SLATE",
  "WHSD-BLACK",
  "WHSD-BLACK-RFID",
  "WHSD-CARAMEL-RFID",
  "WHSD-CHARCOAL",
  "WHSD-CHARCOALARB",
  "WHSD-COCOA",
  "WHSD-COGNAC",
  "WHSD-JAVA",
  "WHSD-JAVA-RFID",
  "WHSD-SLATE",
  "WHSE-BLACK",
  "WHSE-BLACK-RFID",
  "WHSE-CARAMEL-RFID",
  "WHSE-CHARCOAL",
  "WHSE-CHARCOALARB",
  "WHSE-COCOA",
  "WHSE-COGNAC",
  "WHSE-JAVA",
  "WHSE-JAVA-RFID",
  "WHSE-SLATE",
  "WNSC-ARCTICBLUE",
  "WNSC-BLACK",
  "WNSC-BLUESTEEL",
  "WNSC-BURNTORANGE",
  "WNSC-CHARCOAL",
  "WNSC-COCOA",
  "WNSC-JAVA",
  "WNSC-TEAL",
  "WPSA-BLACK",
  "WPSA-CHARCOAL",
  "WPSA-MOCHA",
  "WPSA-TAN",
  "WTRA-CHARCOAL",
  "WTRA-COCOA",
  "WTRA-MIDNIGHT",
  "WTRA-MOCHA",
"WTRA-SLATE"]
skus = ["ENCA-BLACK",
  "ENCA-BLUESTEEL",
  "ENCA-CARAMEL",
  "ENCA-EUCALYPTUS",
  "ENCA-JAVA",
  "PCIA-BLACK",
  "PCIA-BLUESTEEL",
  "PCIA-CHARCOAL",
  "PCIA-JAVA",
  "PCIA-TAMARILLO",
  "PCIB-BLACK",
  "PCIB-BLUESTEEL",
  "PCIB-CHARCOAL",
  "PCIB-JAVA",
  "PCIB-TAMARILLO",
  "PCIC-BLACK",
  "PCIC-BLUESTEEL",
  "PCIC-CHARCOAL",
  "PCIC-JAVA",
  "PCIC-TAMARILLO",
  "PCID-BLACK",
  "PCID-BLUESTEEL",
  "PCID-CHARCOAL",
  "PCID-JAVA",
  "PCID-TAMARILLO",
  "PCIE-BLACK",
  "PCIE-BLUESTEEL",
  "PCIE-CHARCOAL",
  "PCIE-JAVA",
  "PCIE-TAMARILLO",
  "PCPA-BLACK",
  "PCPA-BLUESTEEL",
  "PCPA-CHARCOAL",
  "PCPA-JAVA",
  "PCPA-TAMARILLO",
  "PCPB-BLACK",
  "PCPB-BLUESTEEL",
  "PCPB-CHARCOAL",
  "PCPB-JAVA",
  "PCPB-TAMARILLO",
  "PCPC-BLACK",
  "PCPC-BLUESTEEL",
  "PCPC-CHARCOAL",
  "PCPC-JAVA",
  "PCPC-TAMARILLO",
  "PCPD-BLACK",
  "PCPD-BLUESTEEL",
  "PCPD-CHARCOAL",
  "PCPD-JAVA",
  "PCPD-TAMARILLO",
  "PCPE-BLACK",
  "PCPE-BLUESTEEL",
  "PCPE-CHARCOAL",
  "PCPE-JAVA",
  "PCPE-TAMARILLO",
  "WCFA-BLACK",
  "WCFA-BLUESTEEL",
  "WCFA-JAVA",
  "WCFA-TAMARILLO",
  "WCFB-BLACK",
  "WCFB-BLUESTEEL",
  "WCFB-JAVA",
  "WCFB-TAMARILLO",
  "WEDA-BLACK",
  "WEDA-COGNAC",
  "WEDA-SLATE",
  "WEDB-BLACK",
  "WEDB-COGNAC",
  "WEDB-SLATE",
  "WHSD-BLACK",
  "WHSD-BLACK-RFID",
  "WHSD-CARAMEL-RFID",
  "WHSD-CHARCOAL",
  "WHSD-CHARCOALARB",
  "WHSD-COCOA",
  "WHSD-COGNAC",
  "WHSD-JAVA",
  "WHSD-JAVA-RFID",
  "WHSD-SLATE",
  "WHSE-BLACK",
  "WHSE-BLACK-RFID",
  "WHSE-CARAMEL-RFID",
  "WHSE-CHARCOAL",
  "WHSE-CHARCOALARB",
  "WHSE-COCOA",
  "WHSE-COGNAC",
  "WHSE-JAVA",
  "WHSE-JAVA-RFID",
  "WHSE-SLATE",
  "WNSC-ARCTICBLUE",
  "WNSC-BLACK",
  "WNSC-BLUESTEEL",
  "WNSC-BURNTORANGE",
  "WNSC-CHARCOAL",
  "WNSC-COCOA",
  "WNSC-JAVA",
  "WNSC-TEAL",
  "WPSA-BLACK",
  "WPSA-CHARCOAL",
  "WPSA-MOCHA",
  "WPSA-TAN",
  "WTRA-CHARCOAL",
  "WTRA-COCOA",
  "WTRA-MIDNIGHT",
  "WTRA-MOCHA",
"WTRA-SLATE"]
mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi' }
s = ''
exit
skus = ["ENCA-BLACK",
  "ENCA-BLUESTEEL",
  "ENCA-CARAMEL",
  "ENCA-EUCALYPTUS",
  "ENCA-JAVA",
  "PCIA-BLACK",
  "PCIA-BLUESTEEL",
  "PCIA-CHARCOAL",
  "PCIA-JAVA",
  "PCIA-TAMARILLO",
  "PCIB-BLACK",
  "PCIB-BLUESTEEL",
  "PCIB-CHARCOAL",
  "PCIB-JAVA",
  "PCIB-TAMARILLO",
  "PCIC-BLACK",
  "PCIC-BLUESTEEL",
  "PCIC-CHARCOAL",
  "PCIC-JAVA",
  "PCIC-TAMARILLO",
  "PCID-BLACK",
  "PCID-BLUESTEEL",
  "PCID-CHARCOAL",
  "PCID-JAVA",
  "PCID-TAMARILLO",
  "PCIE-BLACK",
  "PCIE-BLUESTEEL",
  "PCIE-CHARCOAL",
  "PCIE-JAVA",
  "PCIE-TAMARILLO",
  "PCPA-BLACK",
  "PCPA-BLUESTEEL",
  "PCPA-CHARCOAL",
  "PCPA-JAVA",
  "PCPA-TAMARILLO",
  "PCPB-BLACK",
  "PCPB-BLUESTEEL",
  "PCPB-CHARCOAL",
  "PCPB-JAVA",
  "PCPB-TAMARILLO",
  "PCPC-BLACK",
  "PCPC-BLUESTEEL",
  "PCPC-CHARCOAL",
  "PCPC-JAVA",
  "PCPC-TAMARILLO",
  "PCPD-BLACK",
  "PCPD-BLUESTEEL",
  "PCPD-CHARCOAL",
  "PCPD-JAVA",
  "PCPD-TAMARILLO",
  "PCPE-BLACK",
  "PCPE-BLUESTEEL",
  "PCPE-CHARCOAL",
  "PCPE-JAVA",
  "PCPE-TAMARILLO",
  "WCFA-BLACK",
  "WCFA-BLUESTEEL",
  "WCFA-JAVA",
  "WCFA-TAMARILLO",
  "WCFB-BLACK",
  "WCFB-BLUESTEEL",
  "WCFB-JAVA",
  "WCFB-TAMARILLO",
  "WEDA-BLACK",
  "WEDA-COGNAC",
  "WEDA-SLATE",
  "WEDB-BLACK",
  "WEDB-COGNAC",
  "WEDB-SLATE",
  "WHSD-BLACK",
  "WHSD-BLACK-RFID",
  "WHSD-CARAMEL-RFID",
  "WHSD-CHARCOAL",
  "WHSD-CHARCOALARB",
  "WHSD-COCOA",
  "WHSD-COGNAC",
  "WHSD-JAVA",
  "WHSD-JAVA-RFID",
  "WHSD-SLATE",
  "WHSE-BLACK",
  "WHSE-BLACK-RFID",
  "WHSE-CARAMEL-RFID",
  "WHSE-CHARCOAL",
  "WHSE-CHARCOALARB",
  "WHSE-COCOA",
  "WHSE-COGNAC",
  "WHSE-JAVA",
  "WHSE-JAVA-RFID",
  "WHSE-SLATE",
  "WNSC-ARCTICBLUE",
  "WNSC-BLACK",
  "WNSC-BLUESTEEL",
  "WNSC-BURNTORANGE",
  "WNSC-CHARCOAL",
  "WNSC-COCOA",
  "WNSC-JAVA",
  "WNSC-TEAL",
  "WPSA-BLACK",
  "WPSA-CHARCOAL",
  "WPSA-MOCHA",
  "WPSA-TAN",
  "WTRA-CHARCOAL",
  "WTRA-COCOA",
  "WTRA-MIDNIGHT",
  "WTRA-MOCHA",
"WTRA-SLATE"]
mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi' }
s = ''
s = ""
str = ''
OrderLineItem.where(product_sku: skus).all do |order_line_item|
  variant = order_line_item.variant_name
  str += "#{order_line_item.sku}\t#{variant}\t#{mapping[variant]}\n"
end
str
str = ''
OrderLineItem.where(product_sku: skus).all do |order_line_item|
  variant = order_line_item.variant_name
  str += "#{order_line_item.sku}\t#{variant}\t#{mapping[variant]}\n"
end
str
OrderLineItem.where(product_sku: skus).map do |order_line_item|
  variant = order_line_item.variant_name
  "#{order_line_item.sku}\t#{variant}\t#{mapping[variant]}\n"
end.join("\n")
OrderLineItem.where(product_sku: skus).map do |order_line_item|
  variant = order_line_item.variant_name
  "#{order_line_item.product_sku}\t#{variant}\t#{mapping[variant]}\n"
end.join("\n")
OrderLineItem.where(product_sku: skus).map do |order_line_item|
  binding.pry
  variant = order_line_item.variant_name
  "#{order_line_item.product_sku}\t#{variant}\t#{mapping[variant]}"
end.join("\n")
OrderLineItem.where(product_sku: skus).map do |order_line_item|
  variant = order_line_item.variant_name
  "#{order_line_item.product_sku} #{variant} #{mapping[variant]}"
end.join("\n")
OrderLineItem.find("
OrderLineItem.find()
)
OrderLineItem.find(233186)
OrderLineItem.find(233186).variant_name
OrderLineItem.where(product_sku: skus).map do |order_line_item|
  variant = order_line_item.variant_name | 'jojojoj'
  "#{order_line_item.product_sku} #{variant} #{mapping[variant]}"
end.join("\n")
OrderLineItem.where(product_sku: skus).map do |order_line_item|
  variant = order_line_item.variant_name || 'jojojoj'
  "#{order_line_item.product_sku} #{variant} #{mapping[variant]}"
end.join("\n")
skus = ["ENCA-BLACK",
  "ENCA-BLUESTEEL",
  "ENCA-CARAMEL",
  "ENCA-EUCALYPTUS",
  "ENCA-JAVA",
  "PCIA-BLACK",
  "PCIA-BLUESTEEL",
  "PCIA-CHARCOAL",
  "PCIA-JAVA",
  "PCIA-TAMARILLO",
  "PCIB-BLACK",
  "PCIB-BLUESTEEL",
  "PCIB-CHARCOAL",
  "PCIB-JAVA",
  "PCIB-TAMARILLO",
  "PCIC-BLACK",
  "PCIC-BLUESTEEL",
  "PCIC-CHARCOAL",
  "PCIC-JAVA",
  "PCIC-TAMARILLO",
  "PCID-BLACK",
  "PCID-BLUESTEEL",
  "PCID-CHARCOAL",
  "PCID-JAVA",
  "PCID-TAMARILLO",
  "PCIE-BLACK",
  "PCIE-BLUESTEEL",
  "PCIE-CHARCOAL",
  "PCIE-JAVA",
  "PCIE-TAMARILLO",
  "PCPA-BLACK",
  "PCPA-BLUESTEEL",
  "PCPA-CHARCOAL",
  "PCPA-JAVA",
  "PCPA-TAMARILLO",
  "PCPB-BLACK",
  "PCPB-BLUESTEEL",
  "PCPB-CHARCOAL",
  "PCPB-JAVA",
  "PCPB-TAMARILLO",
  "PCPC-BLACK",
  "PCPC-BLUESTEEL",
  "PCPC-CHARCOAL",
  "PCPC-JAVA",
  "PCPC-TAMARILLO",
  "PCPD-BLACK",
  "PCPD-BLUESTEEL",
  "PCPD-CHARCOAL",
  "PCPD-JAVA",
  "PCPD-TAMARILLO",
  "PCPE-BLACK",
  "PCPE-BLUESTEEL",
  "PCPE-CHARCOAL",
  "PCPE-JAVA",
  "PCPE-TAMARILLO",
  "WCFA-BLACK",
  "WCFA-BLUESTEEL",
  "WCFA-JAVA",
  "WCFA-TAMARILLO",
  "WCFB-BLACK",
  "WCFB-BLUESTEEL",
  "WCFB-JAVA",
  "WCFB-TAMARILLO",
  "WEDA-BLACK",
  "WEDA-COGNAC",
  "WEDA-SLATE",
  "WEDB-BLACK",
  "WEDB-COGNAC",
  "WEDB-SLATE",
  "WHSD-BLACK",
  "WHSD-BLACK-RFID",
  "WHSD-CARAMEL-RFID",
  "WHSD-CHARCOAL",
  "WHSD-CHARCOALARB",
  "WHSD-COCOA",
  "WHSD-COGNAC",
  "WHSD-JAVA",
  "WHSD-JAVA-RFID",
  "WHSD-SLATE",
  "WHSE-BLACK",
  "WHSE-BLACK-RFID",
  "WHSE-CARAMEL-RFID",
  "WHSE-CHARCOAL",
  "WHSE-CHARCOALARB",
  "WHSE-COCOA",
  "WHSE-COGNAC",
  "WHSE-JAVA",
  "WHSE-JAVA-RFID",
  "WHSE-SLATE",
  "WNSC-ARCTICBLUE",
  "WNSC-BLACK",
  "WNSC-BLUESTEEL",
  "WNSC-BURNTORANGE",
  "WNSC-CHARCOAL",
  "WNSC-COCOA",
  "WNSC-JAVA",
  "WNSC-TEAL",
  "WPSA-BLACK",
  "WPSA-CHARCOAL",
  "WPSA-MOCHA",
  "WPSA-TAN",
  "WTRA-CHARCOAL",
  "WTRA-COCOA",
  "WTRA-MIDNIGHT",
  "WTRA-MOCHA",
"WTRA-SLATE"]
skus = ["ENCA-BLACK",
  "ENCA-BLUESTEEL",
  "ENCA-CARAMEL",
  "ENCA-EUCALYPTUS",
  "ENCA-JAVA",
  "PCIA-BLACK",
  "PCIA-BLUESTEEL",
  "PCIA-CHARCOAL",
  "PCIA-JAVA",
  "PCIA-TAMARILLO",
  "PCIB-BLACK",
  "PCIB-BLUESTEEL",
  "PCIB-CHARCOAL",
  "PCIB-JAVA",
  "PCIB-TAMARILLO",
  "PCIC-BLACK",
  "PCIC-BLUESTEEL",
  "PCIC-CHARCOAL",
  "PCIC-JAVA",
  "PCIC-TAMARILLO",
  "PCID-BLACK",
  "PCID-BLUESTEEL",
  "PCID-CHARCOAL",
  "PCID-JAVA",
  "PCID-TAMARILLO",
  "PCIE-BLACK",
  "PCIE-BLUESTEEL",
  "PCIE-CHARCOAL",
  "PCIE-JAVA",
  "PCIE-TAMARILLO",
  "PCPA-BLACK",
  "PCPA-BLUESTEEL",
  "PCPA-CHARCOAL",
  "PCPA-JAVA",
  "PCPA-TAMARILLO",
  "PCPB-BLACK",
  "PCPB-BLUESTEEL",
  "PCPB-CHARCOAL",
  "PCPB-JAVA",
  "PCPB-TAMARILLO",
  "PCPC-BLACK",
  "PCPC-BLUESTEEL",
  "PCPC-CHARCOAL",
  "PCPC-JAVA",
  "PCPC-TAMARILLO",
  "PCPD-BLACK",
  "PCPD-BLUESTEEL",
  "PCPD-CHARCOAL",
  "PCPD-JAVA",
  "PCPD-TAMARILLO",
  "PCPE-BLACK",
  "PCPE-BLUESTEEL",
  "PCPE-CHARCOAL",
  "PCPE-JAVA",
  "PCPE-TAMARILLO",
  "WCFA-BLACK",
  "WCFA-BLUESTEEL",
  "WCFA-JAVA",
  "WCFA-TAMARILLO",
  "WCFB-BLACK",
  "WCFB-BLUESTEEL",
  "WCFB-JAVA",
  "WCFB-TAMARILLO",
  "WEDA-BLACK",
  "WEDA-COGNAC",
  "WEDA-SLATE",
  "WEDB-BLACK",
  "WEDB-COGNAC",
  "WEDB-SLATE",
  "WHSD-BLACK",
  "WHSD-BLACK-RFID",
  "WHSD-CARAMEL-RFID",
  "WHSD-CHARCOAL",
  "WHSD-CHARCOALARB",
  "WHSD-COCOA",
  "WHSD-COGNAC",
  "WHSD-JAVA",
  "WHSD-JAVA-RFID",
  "WHSD-SLATE",
  "WHSE-BLACK",
  "WHSE-BLACK-RFID",
  "WHSE-CARAMEL-RFID",
  "WHSE-CHARCOAL",
  "WHSE-CHARCOALARB",
  "WHSE-COCOA",
  "WHSE-COGNAC",
  "WHSE-JAVA",
  "WHSE-JAVA-RFID",
  "WHSE-SLATE",
  "WNSC-ARCTICBLUE",
  "WNSC-BLACK",
  "WNSC-BLUESTEEL",
  "WNSC-BURNTORANGE",
  "WNSC-CHARCOAL",
  "WNSC-COCOA",
  "WNSC-JAVA",
  "WNSC-TEAL",
  "WPSA-BLACK",
  "WPSA-CHARCOAL",
  "WPSA-MOCHA",
  "WPSA-TAN",
  "WTRA-CHARCOAL",
  "WTRA-COCOA",
  "WTRA-MIDNIGHT",
  "WTRA-MOCHA",
"WTRA-SLATE"]
skus = ["ENCA-BLACK",
  "ENCA-BLUESTEEL",
  "ENCA-CARAMEL",
  "ENCA-EUCALYPTUS",
  "ENCA-JAVA",
  "PCIA-BLACK",
  "PCIA-BLUESTEEL",
  "PCIA-CHARCOAL",
  "PCIA-JAVA",
  "PCIA-TAMARILLO",
  "PCIB-BLACK",
  "PCIB-BLUESTEEL",
  "PCIB-CHARCOAL",
  "PCIB-JAVA",
  "PCIB-TAMARILLO",
  "PCIC-BLACK",
  "PCIC-BLUESTEEL",
  "PCIC-CHARCOAL",
  "PCIC-JAVA",
  "PCIC-TAMARILLO",
  "PCID-BLACK",
  "PCID-BLUESTEEL",
  "PCID-CHARCOAL",
  "PCID-JAVA",
  "PCID-TAMARILLO",
  "PCIE-BLACK",
  "PCIE-BLUESTEEL",
  "PCIE-CHARCOAL",
  "PCIE-JAVA",
  "PCIE-TAMARILLO",
  "PCPA-BLACK",
  "PCPA-BLUESTEEL",
  "PCPA-CHARCOAL",
  "PCPA-JAVA",
  "PCPA-TAMARILLO",
  "PCPB-BLACK",
  "PCPB-BLUESTEEL",
  "PCPB-CHARCOAL",
  "PCPB-JAVA",
  "PCPB-TAMARILLO",
  "PCPC-BLACK",
  "PCPC-BLUESTEEL",
  "PCPC-CHARCOAL",
  "PCPC-JAVA",
  "PCPC-TAMARILLO",
  "PCPD-BLACK",
  "PCPD-BLUESTEEL",
  "PCPD-CHARCOAL",
  "PCPD-JAVA",
  "PCPD-TAMARILLO",
  "PCPE-BLACK",
  "PCPE-BLUESTEEL",
  "PCPE-CHARCOAL",
  "PCPE-JAVA",
  "PCPE-TAMARILLO",
  "WCFA-BLACK",
  "WCFA-BLUESTEEL",
  "WCFA-JAVA",
  "WCFA-TAMARILLO",
  "WCFB-BLACK",
  "WCFB-BLUESTEEL",
  "WCFB-JAVA",
  "WCFB-TAMARILLO",
  "WEDA-BLACK",
  "WEDA-COGNAC",
  "WEDA-SLATE",
  "WEDB-BLACK",
  "WEDB-COGNAC",
  "WEDB-SLATE",
  "WHSD-BLACK",
  "WHSD-BLACK-RFID",
  "WHSD-CARAMEL-RFID",
  "WHSD-CHARCOAL",
  "WHSD-CHARCOALARB",
  "WHSD-COCOA",
  "WHSD-COGNAC",
  "WHSD-JAVA",
  "WHSD-JAVA-RFID",
  "WHSD-SLATE",
  "WHSE-BLACK",
  "WHSE-BLACK-RFID",
  "WHSE-CARAMEL-RFID",
  "WHSE-CHARCOAL",
  "WHSE-CHARCOALARB",
  "WHSE-COCOA",
  "WHSE-COGNAC",
  "WHSE-JAVA",
  "WHSE-JAVA-RFID",
  "WHSE-SLATE",
  "WNSC-ARCTICBLUE",
  "WNSC-BLACK",
  "WNSC-BLUESTEEL",
  "WNSC-BURNTORANGE",
  "WNSC-CHARCOAL",
  "WNSC-COCOA",
  "WNSC-JAVA",
  "WNSC-TEAL",
  "WPSA-BLACK",
  "WPSA-CHARCOAL",
  "WPSA-MOCHA",
  "WPSA-TAN",
  "WTRA-CHARCOAL",
  "WTRA-COCOA",
  "WTRA-MIDNIGHT",
  "WTRA-MOCHA",
"WTRA-SLATE"]
mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi' }
skus.each do |sku|
  variants = OrderLineItem.where(product_sku: sku).where.not(variant_name: '').pluck(:variant_name)
  variants.each { |variant| puts "#{sku}, #{variant}, #{mapping[variant]}" }
end
skus.each do |sku|
  variants = OrderLineItem.where(product_sku: sku).where.not(variant_name: '').pluck(:variant_name)
  variants.map { |variant| "#{sku}, #{variant}, #{mapping[variant]}" }
end.uniq.join("\n")
ActiveRecord::Base.logger = nil
skus.map do |sku|
  variants = OrderLineItem.where(product_sku: sku).where.not(variant_name: '').pluck(:variant_name)
  variants.map { |variant| "#{sku}, #{variant}, #{mapping[variant]}" }
end.flatten.uniq.join("\n")
mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi', 'default' => 'leather' }
# OrderLineItem.where(product_sku: skus).map do |order_line_item|
#   variant = order_line_item.variant_name
#   puts "#{order_line_item.product_sku}, #{variant}, #{mapping[variant]}"
# end
ActiveRecord::Base.logger = nil
puts  skus.map do |sku|
  variants = OrderLineItem.where(product_sku: sku).where.not(variant_name: '').pluck(:variant_name)
  variants.map { |variant| "#{sku}, #{variant}, #{mapping[variant]}" }
end.flatten.uniq.join("\n")
mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi', 'default' => 'leather' }
# OrderLineItem.where(product_sku: skus).map do |order_line_item|
#   variant = order_line_item.variant_name
#   puts "#{order_line_item.product_sku}, #{variant}, #{mapping[variant]}"
# end
ActiveRecord::Base.logger = nil
res = skus.map do |sku|
  variants = OrderLineItem.where(product_sku: sku).where.not(variant_name: '').pluck(:variant_name)
  variants.map { |variant| "#{sku}, #{variant}, #{mapping[variant]}" }
end.flatten.uniq.join("\n")
puts res
mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi', 'default' => 'leather' }
# OrderLineItem.where(product_sku: skus).map do |order_line_item|
#   variant = order_line_item.variant_name
#   puts "#{order_line_item.product_sku}, #{variant}, #{mapping[variant]}"
# end
ActiveRecord::Base.logger = nil
res = skus.map do |sku|
  variants = OrderLineItem.where(product_sku: sku).pluck(:variant_name)
  variants.map { |variant| "#{sku}, #{variant}, #{mapping[variant]}" }
end.flatten.uniq.join("\n")
puts res
image_url
image_url "/assets/svg_icons/flags/4x3/cu.svg"
app.image_url "/assets/svg_icons/flags/4x3/cu.svg"
helper.image_url "/assets/svg_icons/flags/4x3/cu.svg"
Product
ProductQuery.all_products
ProductQuery.all_products.last
ProductQuery.all_products.last.variant_name
OrderLineItem
OrderLineItem.last
ActiveRecord::Base.logger = nil
mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi', 'default' => 'leather' }
OrderLineItem.where(product_sku: sku).each |order_line_item| do
variant = order_line_item.variant_name
new_variant = if variant.nil?
  products = ProductQuery.all_products.select { |product| product.sku == order_line_item.sku }
  case products.size
  when 0
    raise 'No Product matching'
  when 1
    products.first.variant_name
  else
    raise 'Multiple matchings'
  end
elsif mapping.keys.include?(variant)
  mapping[variant]
end
puts "Updating sku: #{order_line_item.sku} with variant #{variant} by new_variant: #{new_variant}"
# order_line_item.variant_name = new_variant
# order_line_item.save!
end
def doit
  ActiveRecord::Base.logger = nil
  mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi', 'default' => 'leather' }
  OrderLineItem.where(product_sku: sku).each |order_line_item| do
variant = order_line_item.variant_name
new_variant = if variant.nil?
  products = ProductQuery.all_products.select { |product| product.sku == order_line_item.sku }
  case products.size
  when 0
    raise 'No Product matching'
  when 1
    products.first.variant_name
  else
    raise 'Multiple matchings'
  end
elsif mapping.keys.include?(variant)
  mapping[variant]
end
puts "Updating sku: #{order_line_item.sku} with variant #{variant} by new_variant: #{new_variant}"
# order_line_item.variant_name = new_variant
# order_line_item.save!
end
def doit
  ActiveRecord::Base.logger = nil
  mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi', 'default' => 'leather' }
  OrderLineItem.where(product_sku: sku).each |order_line_item| do
variant = order_line_item.variant_name
new_variant = if variant.nil?
  products = ProductQuery.all_products.select { |product| product.sku == order_line_item.sku }
  case products.size
  when 0
    raise 'No Product matching'
  when 1
    products.first.variant_name
  else
    raise 'Multiple matchings'
  end
elsif mapping.keys.include?(variant)
  mapping[variant]
end
puts "Updating sku: #{order_line_item.sku} with variant #{variant} by new_variant: #{new_variant}"
# order_line_item.variant_name = new_variant
# order_line_item.save!
end
exit
def doit
  ActiveRecord::Base.logger = nil
  mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi', 'default' => 'leather' }
  OrderLineItem.where(product_sku: sku).each |order_line_item| do
variant = order_line_item.variant_name
new_variant = if variant.nil?
  products = ProductQuery.all_products.select { |product| product.sku == order_line_item.sku }
  case products.size
  when 0
    raise 'No Product matching'
  when 1
    products.first.variant_name
  else
    raise 'Multiple matchings'
  end
elsif mapping.keys.include?(variant)
  mapping[variant]
end
puts "Updating sku: #{order_line_item.sku} with variant #{variant} by new_variant: #{new_variant}"
# order_line_item.variant_name = new_variant
# order_line_item.save!
end
def doit
  ActiveRecord::Base.logger = nil
  mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi', 'default' => 'leather' }
  OrderLineItem.where(product_sku: sku).each do |order_line_item|
    variant = order_line_item.variant_name
    new_variant = if variant.nil?
      products = ProductQuery.all_products.select { |product| product.sku == order_line_item.sku }
      case products.size
      when 0
        raise 'No Product matching'
      when 1
        products.first.variant_name
      else
        raise 'Multiple matchings'
      end
    elsif mapping.keys.include?(variant)
      mapping[variant]
    end
    puts "Updating sku: #{order_line_item.sku} with variant #{variant} by new_variant: #{new_variant}"
    # order_line_item.variant_name = new_variant
    # order_line_item.save!
  end
end
doit
def doit
  ActiveRecord::Base.logger = nil
  mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi', 'default' => 'leather' }
  OrderLineItem.where(product_sku: sku).each do |order_line_item|
    variant = order_line_item.variant_name
    new_variant = if variant.nil?
      products = ProductQuery.all_products.select { |product| product.sku == order_line_item.sku }
      case products.size
      when 0
        raise 'No Product matching'
      when 1
        products.first.variant_name
      else
        raise 'Multiple matchings'
      end
    elsif mapping.keys.include?(variant)
      mapping[variant]
    end
    puts "Updating sku: #{order_line_item.product_sku} with variant #{variant} by new_variant: #{new_variant}"
    # order_line_item.variant_name = new_variant
    # order_line_item.save!
  end
end
doit
skus = ["ENCA-BLACK",
  "ENCA-BLUESTEEL",
  "ENCA-CARAMEL",
  "ENCA-EUCALYPTUS",
  "ENCA-JAVA",
  "PCIA-BLACK",
  "PCIA-BLUESTEEL",
  "PCIA-CHARCOAL",
  "PCIA-JAVA",
  "PCIA-TAMARILLO",
  "PCIB-BLACK",
  "PCIB-BLUESTEEL",
  "PCIB-CHARCOAL",
  "PCIB-JAVA",
  "PCIB-TAMARILLO",
  "PCIC-BLACK",
  "PCIC-BLUESTEEL",
  "PCIC-CHARCOAL",
  "PCIC-JAVA",
  "PCIC-TAMARILLO",
  "PCID-BLACK",
  "PCID-BLUESTEEL",
  "PCID-CHARCOAL",
  "PCID-JAVA",
  "PCID-TAMARILLO",
  "PCIE-BLACK",
  "PCIE-BLUESTEEL",
  "PCIE-CHARCOAL",
  "PCIE-JAVA",
  "PCIE-TAMARILLO",
  "PCPA-BLACK",
  "PCPA-BLUESTEEL",
  "PCPA-CHARCOAL",
  "PCPA-JAVA",
  "PCPA-TAMARILLO",
  "PCPB-BLACK",
  "PCPB-BLUESTEEL",
  "PCPB-CHARCOAL",
  "PCPB-JAVA",
  "PCPB-TAMARILLO",
  "PCPC-BLACK",
  "PCPC-BLUESTEEL",
  "PCPC-CHARCOAL",
  "PCPC-JAVA",
  "PCPC-TAMARILLO",
  "PCPD-BLACK",
  "PCPD-BLUESTEEL",
  "PCPD-CHARCOAL",
  "PCPD-JAVA",
  "PCPD-TAMARILLO",
  "PCPE-BLACK",
  "PCPE-BLUESTEEL",
  "PCPE-CHARCOAL",
  "PCPE-JAVA",
  "PCPE-TAMARILLO",
  "WCFA-BLACK",
  "WCFA-BLUESTEEL",
  "WCFA-JAVA",
  "WCFA-TAMARILLO",
  "WCFB-BLACK",
  "WCFB-BLUESTEEL",
  "WCFB-JAVA",
  "WCFB-TAMARILLO",
  "WEDA-BLACK",
  "WEDA-COGNAC",
  "WEDA-SLATE",
  "WEDB-BLACK",
  "WEDB-COGNAC",
  "WEDB-SLATE",
  "WHSD-BLACK",
  "WHSD-BLACK-RFID",
  "WHSD-CARAMEL-RFID",
  "WHSD-CHARCOAL",
  "WHSD-CHARCOALARB",
  "WHSD-COCOA",
  "WHSD-COGNAC",
  "WHSD-JAVA",
  "WHSD-JAVA-RFID",
  "WHSD-SLATE",
  "WHSE-BLACK",
  "WHSE-BLACK-RFID",
  "WHSE-CARAMEL-RFID",
  "WHSE-CHARCOAL",
  "WHSE-CHARCOALARB",
  "WHSE-COCOA",
  "WHSE-COGNAC",
  "WHSE-JAVA",
  "WHSE-JAVA-RFID",
  "WHSE-SLATE",
  "WNSC-ARCTICBLUE",
  "WNSC-BLACK",
  "WNSC-BLUESTEEL",
  "WNSC-BURNTORANGE",
  "WNSC-CHARCOAL",
  "WNSC-COCOA",
  "WNSC-JAVA",
  "WNSC-TEAL",
  "WPSA-BLACK",
  "WPSA-CHARCOAL",
  "WPSA-MOCHA",
  "WPSA-TAN",
  "WTRA-CHARCOAL",
  "WTRA-COCOA",
  "WTRA-MIDNIGHT",
  "WTRA-MOCHA",
"WTRA-SLATE"]
skus = ["ENCA-BLACK",
  "ENCA-BLUESTEEL",
  "ENCA-CARAMEL",
  "ENCA-EUCALYPTUS",
  "ENCA-JAVA",
  "PCIA-BLACK",
  "PCIA-BLUESTEEL",
  "PCIA-CHARCOAL",
  "PCIA-JAVA",
  "PCIA-TAMARILLO",
  "PCIB-BLACK",
  "PCIB-BLUESTEEL",
  "PCIB-CHARCOAL",
  "PCIB-JAVA",
  "PCIB-TAMARILLO",
  "PCIC-BLACK",
  "PCIC-BLUESTEEL",
  "PCIC-CHARCOAL",
  "PCIC-JAVA",
  "PCIC-TAMARILLO",
  "PCID-BLACK",
  "PCID-BLUESTEEL",
  "PCID-CHARCOAL",
  "PCID-JAVA",
  "PCID-TAMARILLO",
  "PCIE-BLACK",
  "PCIE-BLUESTEEL",
  "PCIE-CHARCOAL",
  "PCIE-JAVA",
  "PCIE-TAMARILLO",
  "PCPA-BLACK",
  "PCPA-BLUESTEEL",
  "PCPA-CHARCOAL",
  "PCPA-JAVA",
  "PCPA-TAMARILLO",
  "PCPB-BLACK",
  "PCPB-BLUESTEEL",
  "PCPB-CHARCOAL",
  "PCPB-JAVA",
  "PCPB-TAMARILLO",
  "PCPC-BLACK",
  "PCPC-BLUESTEEL",
  "PCPC-CHARCOAL",
  "PCPC-JAVA",
  "PCPC-TAMARILLO",
  "PCPD-BLACK",
  "PCPD-BLUESTEEL",
  "PCPD-CHARCOAL",
  "PCPD-JAVA",
  "PCPD-TAMARILLO",
  "PCPE-BLACK",
  "PCPE-BLUESTEEL",
  "PCPE-CHARCOAL",
  "PCPE-JAVA",
  "PCPE-TAMARILLO",
  "WCFA-BLACK",
  "WCFA-BLUESTEEL",
  "WCFA-JAVA",
  "WCFA-TAMARILLO",
  "WCFB-BLACK",
  "WCFB-BLUESTEEL",
  "WCFB-JAVA",
  "WCFB-TAMARILLO",
  "WEDA-BLACK",
  "WEDA-COGNAC",
  "WEDA-SLATE",
  "WEDB-BLACK",
  "WEDB-COGNAC",
  "WEDB-SLATE",
  "WHSD-BLACK",
  "WHSD-BLACK-RFID",
  "WHSD-CARAMEL-RFID",
  "WHSD-CHARCOAL",
  "WHSD-CHARCOALARB",
  "WHSD-COCOA",
  "WHSD-COGNAC",
  "WHSD-JAVA",
  "WHSD-JAVA-RFID",
  "WHSD-SLATE",
  "WHSE-BLACK",
  "WHSE-BLACK-RFID",
  "WHSE-CARAMEL-RFID",
  "WHSE-CHARCOAL",
  "WHSE-CHARCOALARB",
  "WHSE-COCOA",
  "WHSE-COGNAC",
  "WHSE-JAVA",
  "WHSE-JAVA-RFID",
  "WHSE-SLATE",
  "WNSC-ARCTICBLUE",
  "WNSC-BLACK",
  "WNSC-BLUESTEEL",
  "WNSC-BURNTORANGE",
  "WNSC-CHARCOAL",
  "WNSC-COCOA",
  "WNSC-JAVA",
  "WNSC-TEAL",
  "WPSA-BLACK",
  "WPSA-CHARCOAL",
  "WPSA-MOCHA",
  "WPSA-TAN",
  "WTRA-CHARCOAL",
  "WTRA-COCOA",
  "WTRA-MIDNIGHT",
  "WTRA-MOCHA",
"WTRA-SLATE"]
def doit
  ActiveRecord::Base.logger = nil
  mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi', 'default' => 'leather' }
  OrderLineItem.where(product_sku: skus).each do |order_line_item|
    variant = order_line_item.variant_name
    new_variant = if variant.nil?
      products = ProductQuery.all_products.select { |product| product.sku == order_line_item.sku }
      case products.size
      when 0
        raise 'No Product matching'
      when 1
        products.first.variant_name
      else
        raise 'Multiple matchings'
      end
    elsif mapping.keys.include?(variant)
      mapping[variant]
    end
    puts "Updating sku: #{order_line_item.product_sku} with variant #{variant} by new_variant: #{new_variant}"
    # order_line_item.variant_name = new_variant
    # order_line_item.save!
  end
  doit
end
def doit
  ActiveRecord::Base.logger = nil
  mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi', 'default' => 'leather' }
  OrderLineItem.where(product_sku: skus).each do |order_line_item|
    variant = order_line_item.variant_name
    new_variant = if variant.nil?
      products = ProductQuery.all_products.select { |product| product.sku == order_line_item.sku }
      case products.size
      when 0
        raise 'No Product matching'
      when 1
        products.first.variant_name
      else
        raise 'Multiple matchings'
      end
    elsif mapping.keys.include?(variant)
      mapping[variant]
    end
    puts "Updating sku: #{order_line_item.product_sku} with variant #{variant} by new_variant: #{new_variant}"
    # order_line_item.variant_name = new_variant
    # order_line_item.save!
  end
end
doit
skus
def doit(skus)
  ActiveRecord::Base.logger = nil
  mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi', 'default' => 'leather' }
  OrderLineItem.where(product_sku: skus).each do |order_line_item|
    variant = order_line_item.variant_name
    new_variant = if variant.nil?
      products = ProductQuery.all_products.select { |product| product.sku == order_line_item.sku }
      case products.size
      when 0
        raise 'No Product matching'
      when 1
        products.first.variant_name
      else
        raise 'Multiple matchings'
      end
    elsif mapping.keys.include?(variant)
      mapping[variant]
    end
    puts "Updating sku: #{order_line_item.product_sku} with variant #{variant} by new_variant: #{new_variant}"
    # order_line_item.variant_name = new_variant
    # order_line_item.save!
  end
end
doit skus
ProductQuery.all_products.last
ProductQuery.all_products.last.sku
def doit(skus)
  ActiveRecord::Base.logger = nil
  mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi', 'default' => 'leather' }
  OrderLineItem.where(product_sku: skus).each do |order_line_item|
    variant = order_line_item.variant_name
    new_variant = if variant.nil?
      products = ProductQuery.all_products.select { |product| product.sku == order_line_item.product_sku }
      case products.size
      when 0
        raise 'No Product matching'
      when 1
        products.first.variant_name
      else
        raise 'Multiple matchings'
      end
    elsif mapping.keys.include?(variant)
      mapping[variant]
    end
    puts "Updating sku: #{order_line_item.product_sku} with variant #{variant} by new_variant: #{new_variant}"
    # order_line_item.variant_name = new_variant
    # order_line_item.save!
  end
end
doit skus
def doit(skus)
  ActiveRecord::Base.logger = nil
  mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi', 'default' => 'leather' }
  OrderLineItem.where(product_sku: skus).each do |order_line_item|
    puts order_line_item.product_sku
    variant = order_line_item.variant_name
    new_variant = if variant.nil?
      products = ProductQuery.all_products.select { |product| product.sku == order_line_item.product_sku }
      case products.size
      when 0
        raise 'No Product matching'
      when 1
        products.first.variant_name
      else
        raise 'Multiple matchings'
      end
    elsif mapping.keys.include?(variant)
      mapping[variant]
    end
    puts "Updating sku: #{order_line_item.product_sku} with variant #{variant} by new_variant: #{new_variant}"
    # order_line_item.variant_name = new_variant
    # order_line_item.save!
  end
end
doit skus
ProductQuery.all_products.select { |product| product.sku == 'PCIE-CHARCOAL' }
ProductQuery.all_products.select { |product| product.sku == 'PCIE-CHARCOAL' }.map(&:variant)
ProductQuery.all_products.select { |product| product.sku == 'PCIE-CHARCOAL' }.map(&:variant).map(&:variant_name)
ProductQuery.all_products.select { |product| product.sku == 'PCIE-CHARCOAL' }.map(&:variant).last
ProductQuery.all_products.select { |product| product.sku == 'PCIE-CHARCOAL' }.map(&:variant).map(&:material_label)
skus = ["ENCA-BLACK",
  "ENCA-BLUESTEEL",
  "ENCA-CARAMEL",
  "ENCA-EUCALYPTUS",
  "ENCA-JAVA",
  "PCIA-BLACK",
  "PCIA-BLUESTEEL",
  "PCIA-CHARCOAL",
  "PCIA-JAVA",
  "PCIA-TAMARILLO",
  "PCIB-BLACK",
  "PCIB-BLUESTEEL",
  "PCIB-CHARCOAL",
  "PCIB-JAVA",
  "PCIB-TAMARILLO",
  "PCIC-BLACK",
  "PCIC-BLUESTEEL",
  "PCIC-CHARCOAL",
  "PCIC-JAVA",
  "PCIC-TAMARILLO",
  "PCID-BLACK",
  "PCID-BLUESTEEL",
  "PCID-CHARCOAL",
  "PCID-JAVA",
  "PCID-TAMARILLO",
  "PCIE-BLACK",
  "PCIE-BLUESTEEL",
  "PCIE-CHARCOAL",
  "PCIE-JAVA",
  "PCIE-TAMARILLO",
  "PCPA-BLACK",
  "PCPA-BLUESTEEL",
  "PCPA-CHARCOAL",
  "PCPA-JAVA",
  "PCPA-TAMARILLO",
  "PCPB-BLACK",
  "PCPB-BLUESTEEL",
  "PCPB-CHARCOAL",
  "PCPB-JAVA",
  "PCPB-TAMARILLO",
  "PCPC-BLACK",
  "PCPC-BLUESTEEL",
  "PCPC-CHARCOAL",
  "PCPC-JAVA",
  "PCPC-TAMARILLO",
  "PCPD-BLACK",
  "PCPD-BLUESTEEL",
  "PCPD-CHARCOAL",
  "PCPD-JAVA",
  "PCPD-TAMARILLO",
  "PCPE-BLACK",
  "PCPE-BLUESTEEL",
  "PCPE-CHARCOAL",
  "PCPE-JAVA",
  "PCPE-TAMARILLO",
  "WCFA-BLACK",
  "WCFA-BLUESTEEL",
  "WCFA-JAVA",
  "WCFA-TAMARILLO",
  "WCFB-BLACK",
  "WCFB-BLUESTEEL",
  "WCFB-JAVA",
  "WCFB-TAMARILLO",
  "WEDA-BLACK",
  "WEDA-COGNAC",
  "WEDA-SLATE",
  "WEDB-BLACK",
  "WEDB-COGNAC",
  "WEDB-SLATE",
  "WHSD-BLACK",
  "WHSD-BLACK-RFID",
  "WHSD-CARAMEL-RFID",
  "WHSD-CHARCOAL",
  "WHSD-CHARCOALARB",
  "WHSD-COCOA",
  "WHSD-COGNAC",
  "WHSD-JAVA",
  "WHSD-JAVA-RFID",
  "WHSD-SLATE",
  "WHSE-BLACK",
  "WHSE-BLACK-RFID",
  "WHSE-CARAMEL-RFID",
  "WHSE-CHARCOAL",
  "WHSE-CHARCOALARB",
  "WHSE-COCOA",
  "WHSE-COGNAC",
  "WHSE-JAVA",
  "WHSE-JAVA-RFID",
  "WHSE-SLATE",
  "WNSC-ARCTICBLUE",
  "WNSC-BLACK",
  "WNSC-BLUESTEEL",
  "WNSC-BURNTORANGE",
  "WNSC-CHARCOAL",
  "WNSC-COCOA",
  "WNSC-JAVA",
  "WNSC-TEAL",
  "WPSA-BLACK",
  "WPSA-CHARCOAL",
  "WPSA-MOCHA",
  "WPSA-TAN",
  "WTRA-CHARCOAL",
  "WTRA-COCOA",
  "WTRA-MIDNIGHT",
  "WTRA-MOCHA",
"WTRA-SLATE"]
uery.all_products.select { |product| product.sku == 'PCIE-CHARCOAL' }
skus = ["ENCA-BLACK",
  "ENCA-BLUESTEEL",
  "ENCA-CARAMEL",
  "ENCA-EUCALYPTUS",
  "ENCA-JAVA",
  "PCIA-BLACK",
  "PCIA-BLUESTEEL",
  "PCIA-CHARCOAL",
  "PCIA-JAVA",
  "PCIA-TAMARILLO",
  "PCIB-BLACK",
  "PCIB-BLUESTEEL",
  "PCIB-CHARCOAL",
  "PCIB-JAVA",
  "PCIB-TAMARILLO",
  "PCIC-BLACK",
  "PCIC-BLUESTEEL",
  "PCIC-CHARCOAL",
  "PCIC-JAVA",
  "PCIC-TAMARILLO",
  "PCID-BLACK",
  "PCID-BLUESTEEL",
  "PCID-CHARCOAL",
  "PCID-JAVA",
  "PCID-TAMARILLO",
  "PCIE-BLACK",
  "PCIE-BLUESTEEL",
  "PCIE-CHARCOAL",
  "PCIE-JAVA",
  "PCIE-TAMARILLO",
  "PCPA-BLACK",
  "PCPA-BLUESTEEL",
  "PCPA-CHARCOAL",
  "PCPA-JAVA",
  "PCPA-TAMARILLO",
  "PCPB-BLACK",
  "PCPB-BLUESTEEL",
  "PCPB-CHARCOAL",
  "PCPB-JAVA",
  "PCPB-TAMARILLO",
  "PCPC-BLACK",
  "PCPC-BLUESTEEL",
  "PCPC-CHARCOAL",
  "PCPC-JAVA",
  "PCPC-TAMARILLO",
  "PCPD-BLACK",
  "PCPD-BLUESTEEL",
  "PCPD-CHARCOAL",
  "PCPD-JAVA",
  "PCPD-TAMARILLO",
  "PCPE-BLACK",
  "PCPE-BLUESTEEL",
  "PCPE-CHARCOAL",
  "PCPE-JAVA",
  "PCPE-TAMARILLO",
  "WCFA-BLACK",
  "WCFA-BLUESTEEL",
  "WCFA-JAVA",
  "WCFA-TAMARILLO",
  "WCFB-BLACK",
  "WCFB-BLUESTEEL",
  "WCFB-JAVA",
  "WCFB-TAMARILLO",
  "WEDA-BLACK",
  "WEDA-COGNAC",
  "WEDA-SLATE",
  "WEDB-BLACK",
  "WEDB-COGNAC",
  "WEDB-SLATE",
  "WHSD-BLACK",
  "WHSD-BLACK-RFID",
  "WHSD-CARAMEL-RFID",
  "WHSD-CHARCOAL",
  "WHSD-CHARCOALARB",
  "WHSD-COCOA",
  "WHSD-COGNAC",
  "WHSD-JAVA",
  "WHSD-JAVA-RFID",
  "WHSD-SLATE",
  "WHSE-BLACK",
  "WHSE-BLACK-RFID",
  "WHSE-CARAMEL-RFID",
  "WHSE-CHARCOAL",
  "WHSE-CHARCOALARB",
  "WHSE-COCOA",
  "WHSE-COGNAC",
  "WHSE-JAVA",
  "WHSE-JAVA-RFID",
  "WHSE-SLATE",
  "WNSC-ARCTICBLUE",
  "WNSC-BLACK",
  "WNSC-BLUESTEEL",
  "WNSC-BURNTORANGE",
  "WNSC-CHARCOAL",
  "WNSC-COCOA",
  "WNSC-JAVA",
  "WNSC-TEAL",
  "WPSA-BLACK",
  "WPSA-CHARCOAL",
  "WPSA-MOCHA",
  "WPSA-TAN",
  "WTRA-CHARCOAL",
  "WTRA-COCOA",
  "WTRA-MIDNIGHT",
  "WTRA-MOCHA",
"WTRA-SLATE"]
def doit(skus)
  ActiveRecord::Base.logger = nil
  mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi', 'default' => 'leather' }
  OrderLineItem.where(product_sku: skus).each do |order_line_item|
    puts order_line_item.product_sku
    variant = order_line_item.variant_name
    new_variant = if variant.nil?
      products = ProductQuery.all_products.select { |product| product.sku == order_line_item.product_sku }
      case products.size
      when 0
        raise 'No Product matching'
      when 1
        products.first.variant_name
      else
        raise 'Multiple matchings'
      end
    elsif mapping.keys.include?(variant)
      mapping[variant]
    end
    puts "Updating sku: #{order_line_item.product_sku} with variant #{variant} by new_variant: #{new_variant}"
    # order_line_item.variant_name = new_variant
    # order_line_item.save!
  end
end
doit
doit skus
def doit(skus)
  ActiveRecord::Base.logger = nil
  mapping = { 'lo' => 'leather_lo',  'hi' => 'leather_hi', 'lo_rfid' => 'leather_rfid_lo', 'hi_rfid' => 'leather_rfid_hi', 'default' => 'leather' }
  count = 0
  OrderLineItem.where(product_sku: skus).each do |order_line_item|
    puts order_line_item.product_sku
    variant = order_line_item.variant_name
    new_variant = if variant.nil?
      products = ProductQuery.all_products.select { |product| product.sku == order_line_item.product_sku }
      case products.size
      when 0
        raise 'No Product matching'
      when 1
        products.first.variant_name
      else
        count =+ 1
        #raise 'Multiple matchings'
      end
    elsif mapping.keys.include?(variant)
      mapping[variant]
    end
    puts "Updating sku: #{order_line_item.product_sku} with variant #{variant} by new_variant: #{new_variant}"
    # order_line_item.variant_name = new_variant
    # order_line_item.save!
  end
  puts "Count #{count}"
end
doit
doit skus
skus.each do |sku|
  count = 0
  products = ProductQuery.all_products.select { |product| product.sku == sku }
  case products.size
  when 0
    raise 'No Product matching'
  when 1
    #products.first.variant_name
  else
    count =+ 1
    #raise 'Multiple matchings'
  end
end
count
count = 0
skus.each do |sku|
  products = ProductQuery.all_products.select { |product| product.sku == sku }
  case products.size
  when 0
    raise 'No Product matching'
  when 1
    #products.first.variant_name
  else
    count =+ 1
    #raise 'Multiple matchings'
  end
end
count
count = 0
skus.each do |sku|
  products = ProductQuery.all_products.select { |product| product.sku == sku }
  case products.size
  when 0
    raise 'No Product matching'
  when 1
    #products.first.variant_name
  else
    count =+ 1
    puts sku
    #raise 'Multiple matchings'
  end
end;nil
count
count = 0
skus.each do |sku|
  products = ProductQuery.all_products.select { |product| product.sku == sku }
  case products.size
  when 0
    raise 'No Product matching'
  when 1
    #products.first.variant_name
  else
    count += 1
    puts sku
    #raise 'Multiple matchings'
  end
end;nil
count
visitor_price_group
VisitorPriceGroup.count
exit
previous_price_group
next
previous_price_group
google_shopping_request?
previous_price_group != Product::Price::DEFAULT_GROUP
next
step
n
experiment_variant_nam
experiment_variant_name
n
"pricing_#{current_currency.code.downcase}"
n
step
@google_shopping_price_group_forced_changes
exit
next
file
next
@google_shopping_price_group_forced_changes
@google_shopping_price_group_forced_changes.class
next
exit
session
inspect session
session.inspect
session
session{:sid}
sesessioin[:ssi]
sesession[:sid}
sesession[:sid]
session[;sid]
session[:sid]
session[:id]
session.id
exit
Split.redis
Split.redis.hsetnx 'trike', 'hola', 0 
Split.redis.hget('trike', 'hola')
Split.redis.hsetnx 'trike', 'hola', 100
Split.redis.hget('trike', 'hola')
Split.redis.hsetnx 'trike', 'holas', 100
Split.redis.hget('trike', 'holas')
Split.redis.hsetnx 'trike', 'holas', 1000
Split.redis.hsetnx 'trike', 'holas', 1
Split.redis.hset 'trike', 'holas', 1
Split.redis.hget('trike', 'holas')
Split.redis.hset 'trike', 'holas', 1111
Split.redis.hget('trike', 'holas')
Split.redis
Split.redis.hset('trike', 'hola', 15)
Split.redis.hget('trike', 'hola')
@data
exit
Split::Experiment.new
Split::Experiment.all
Split::Experiment
Split::ExperimentCatalog
Split::ExperimentCatalog.all
Split::Experiment.new('trike')
Split::ExperimentCatalog.all
Split::Experiment.new('trike')
Split::Experiment.new('trike').save!
Split::Experiment.new('trike').save
Split::Experiment.new('trike', alternatives: ['hola', 'mundo']).save
Split::ExperimentCatalog.all
valid_experiments
valid_alternatives
fields
experiments.all? { |experiment| experiment.in?(valid_experiments) }
alternatives.all? { |alternative| alternative.in?(valid_alternatives) }
experiments
exit
experiments.all? { |experiment| experiment.in?(valid_experiments) }
valid_experiments
experiments
exit
valid_experiments
experimetns
experiments
valid_alternatives
emacs .
exit
override_params
override_params[:override]
override_params.methods
override_params
override_params.params
override_params[:params]
override_params[:apple_pay]
override_params.to_h
ActionController::Parameters.new({a:1})
exit
valid_experiments
experiments
next
valid_experiments
experiments
experiments.all? { |experiment| experiment.in?(valid_experiments) }
alternatives.all? { |alternative| alternative.in?(valid_alternatives) }
valid_alternatives
next
valid_alternatives
alternatives
alternatives.all? { |alternative| alternative.in?(valid_alternatives) }
fields.all? { |field| field.in? VALID_FIELDS }
exit
next
experiments.all? { |experiment| experiment.in?(valid_experiments) }
alternatives.all? { |alternative| alternative.in?(valid_alternatives) }
fields.all? { |field| field.in? VALID_FIELDS }
exit
valid_experiments
experiments.all? { |experiment| experiment.in?(valid_experiments) }
alternatives.all? { |alternative| alternative.in?(valid_alternatives) }
next
experiments.all? { |experiment| experiment.in?(valid_experiments) }
next
experiments.all? { |experiment| experiment.in?(valid_experiments) }
alternatives.all? { |alternative| alternative.in?(valid_alternatives) }
fields.all? { |field| field.in? VALID_FIELDS }
experiments
valid_experiments
{'hola'=>5}.with_indifferent_access
{'hola'=>5}.with_indifferent_access.keys
exit
Rails.application.secrets.data_team_api_token
token
next
token
exit
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('fd', 'G[1] pry(#<RSpec::ExampleGroups::V1AllocationsController::Index::WithInvalidApiKey>)> fd')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('se', 'G[1] pry(#<RSpec::ExampleGroups::V1AllocationsController::Index::WithInvalidApiKey>)> se')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('sel', 'G[1] pry(#<RSpec::ExampleGroups::V1AllocationsController::Index::WithInvalidApiKey>)> sel')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('self', 'G[1] pry(#<RSpec::ExampleGroups::V1AllocationsController::Index::WithInvalidApiKey>)> self')
self
5 + 45
5 + 5
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('fd', 'G[1] pry(#<Bellroy::Order>)> fd')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Bel', 'Bel')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Bellroy::', 'Bellroy::')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Bellroy::O', 'Bellroy::O')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Bellroy::Or', 'Bellroy::Or')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Bellroy::Ore', 'Bellroy::Ore')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Bellroy', 'Bellroy::Ore')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Bell', '[1] pry(#<Bellroy::Order>)> Bell')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Bellroy::', '[1] pry(#<Bellroy::Order>)> Bellroy::')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Bellroy::O', '[1] pry(#<Bellroy::Order>)> Bellroy::O')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Bellroy::Or', '[1] pry(#<Bellroy::Order>)> Bellroy::Or')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Bellroy::Ord', '[1] pry(#<Bellroy::Order>)> Bellroy::Ord')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Bellroy::Orde', '[1] pry(#<Bellroy::Order>)> Bellroy::Orde')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Bellroy::Order', '[1] pry(#<Bellroy::Order>)> Bellroy::Order')
Bellroy::Order
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Bellroy::Order.', 'Bellroy::Order.')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Order.', 'Order.')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Order.l', 'Order.l')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Order.la', 'Order.la')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Order', 'Order.la')
Order.last
Order
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Order.', 'Order.')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Order.l', 'Order.l')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Order.la', 'Order.la')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('Order', 'Order.la')
Beldsad
messages
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('invalid', 'invalid')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('invalid_', 'invalid_')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('invalid_e', 'invalid_e')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('invalid_ex', 'invalid_ex')
invalid_experiments
exit
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('fd', 'fd')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('RULES', 'RULES')
rules
ls
Order
Order#methods
instance variables
locals
#methods
ls --methods
ls
find-method xpath Nokogiri
find-method find Order
find-method default Order
find-method default
ls Order
ls Order#methods
stat Order.state
stat Order#state
stat Order#max_page
stat Order.max_page
stat Order.max_pages
show-source Order.max_pages
show-doc Order.max_pages
show-doc Order#state
show-doc Order.max_pages
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('..fd', '..fd')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('', '..fd')
date
query
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('date', 'date')
date
rule
rule.class
date <= query[:date]
continue
date
query
date <= query[:date]
    39:   else
39:   else
SyntaxError: unexpected ':', expecting end-of-input
    39:   elsedate <= query[:date]
date <= query[:date]
continue
vat_details
vat_details.currency_code
vat_details
n
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('conver', 'conver')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('converfds', 'converfds')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('converted', 'converted')
converted
vat
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('endva', '    37: endva')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('vat_', 'vat_')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('vat_d', 'vat_d')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('vat_de', 'vat_de')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('self.', 'self.')
self.class.available_warehouses
into
step
Kaos::ShippingConfig::LandmarkShippingRule.all
Kaos::ShippingConfig::LandmarkShippingRule
Kaos::ShippingConfig::LandmarkShippingRule.last
Kaos::ShippingConfig::LandmarkShippingRule.count
exit
Kaos::ShippingConfig::LandmarkShippingRule.count
exit
next
exit
Kaos::ShippingConfig::LandmarkShippingRule.all.map
Kaos::ShippingConfig::LandmarkShippingRule.all
Kaos::ShippingConfig::LandmarkShippingRule.all.first
Kaos::ShippingConfig::LandmarkShippingRule.all.first[title]
continue
Kaos::ShippingConfig::LandmarkShippingRule.all.first[title]
title
exit
rule
query
next
match?(rule, query)
exit
key
value
n
rule_value
rule_value.present? && rule_value != 'Any'
n
key
exit
excit
exit
n
rule_value
n
value
rule_value.present? && rule_value != 'Any'
value.to_s.downcase.in?(rule_value.to_s.downcase.split(';'))
1.in?1
1.in?(1)
"US".in?("US")
"US".include?("US")
n
key
value
n
rule_value
n
value.to_s.downcase.in?(rule_value.to_s.downcase.split(';'))
n
key
value
n
key
value
n
key
n
rule.saasu_file_identifier == saasu_file_identifier.to_s.upcase
rule.saasu_file_identifier
saasu_file_identifier.to_s.upcase
saasu_file_identifier
newxrt
n
exit
query
rule.saasu_contact_uid.casecmp('any').zero?
n
rule.saasu_file_identifier.casecmp('any').zero?
rule.saasu_file_identifier
rule
query
rules
step
exit
rule
query
match?(rule, query)
exit
key
n
key
n
key
n
key
n
key
n
key
n
key
n
key
n
key
value
rule_value.present?
rule
rule[key]
rule_value = rule[key]
rule_value.present?
rule_value.try(:casecmp, 'any').try(:zero?)
n
value.to_s.downcase.in?(rule_value.to_s.downcase.split(';'))
value.to_s.downcase
rule_value.to_s.downcase.split(';')
key
value
value.to_s.downcase.in?(rule_value.to_s.downcase.split(';'))
n
key
n
key
n
key
n
key
query
n
key
n
key
n
key
value
rule_value
n
rule_value.try(:casecmp, 'any').try(:zero?)
n
key
value
value.to_s.downcase.in?(rule_value.to_s.downcase.split(';'))
value
rule
[1,2].include?(nil)
rule
match?(rule, query)
n
match?(rule, query)
rule
query
exity
exit
n
q
n
continue
n
s
LandmarkPresenter.new(invoice)
n
log_post_action(presenter)
Landmark.post(presenter.payload, invoice_number: invoice_number)
presener.payload
presenter.payload
n
q
n
exit
warehouse_indicators.size
exit
!
exit!
warehouse_indicators.size
n
continue
User.last
u = User.last
u.name = 'Ruslan'
u.save!(validae: false)
[1,2].exclude?1
[1,2].exclude?5
exit
invoice.invoice_items
invoice.invoice_items.first
invoice.invoice_items.first.methods
inspect invoice.invoice_items.first.methods
puts invoice.invoice_items.first.methods
puts invoice.invoice_items.first.methods.tax_code
puts invoice.invoice_items.first.tax_code
invoice.invoice_items.map(&:tax_code).uniq
invoice.invoice_items.map(&:tax_code)
exit
invoice.invoice_items.map(&:tax_code).uniq
invoice.invoice_items.fisrt
invoice.invoice_items.first
invoice.invoice_items.first.tax_code
invoice.invoice_items.first.tax_name
invoice.invoice_items.first.uid
invoice.invoice_items.first.code
exit
tracking
tracking?
self
continue
tracking
self
continue
tracking
self
tracking
tracking?
tracking
self.tracking
exit
KAos
Kaos
Kaos::ShippingConfig
Kaos::ShippingConfig::Rate.count
Kaos::ShippingConfig::Rate.first
Kaos::ShippingConfig::Rate.last
Kaos::ShippingConfig::Rate.last.english_description
Kaos::ShippingConfig::Rate.first.english_description
[1,nil].join('-')
self
Kaos::ShippingConfig::Rate.first
Kaos::ShippingConfig::Rate.first.type
exit
Kaos::ShippingConfig::Rate.first
Kaos::ShippingConfig::Rate.first.english_description
Kaos::ShippingConfig::Rate.last.english_description
exit
exit!
tax_code_match?
tax_code_from_saasu
tax_code
exit!
continue
response
response.location
resources_params
exit
id
attributes
exit!
column_names
next
exit
exit!
column_names.zip(incoming_attributes).to_h.except(*PROTECTED_FIELDS)
incoming_attributes
column_names.zip(incoming_attributes).to_h.except(*PROTECTED_FIELDS)
incoming_attributes
column_names.zip(incoming_attributes).to_h.except(*PROTECTED_FIELDS)
incoming_attributes
column_names.zip(incoming_attributes)
resource_class
resource_params
exit
column_names.zip(incoming_attributes).to_h.except(*PROTECTED_FIELDS)
resources_params
resources_params.first
column_names.zip(incoming_attributes).to_h.except(*PROTECTED_FIELDS)
resource_class
resource_class.to_h
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('experiment', 'experiment')
experiment
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('experiment.', 'experiment.')
experiment
experiment.calc_time
experiment.calc_time = 3
experiment.save!
experiment.save
experiment.calc_time
exit
target_database_connection_config
Siegfried::Config.database
target_database_name
exit
Rails.configuration.database_configuration[database_name]
database_name
Rails.configuration.database_configuration
exit
ActiveRecord::Base.schema_format
ActiveRecord::Base
ActiveRecord::Base.connection
ActiveRecord::Base.connection.class
Application.config
Application.config.active_record
Application.config.active_record.schema_format
Application.config.active_record.schema_format = :sql
continue
Payment.last
Payment.new
p = Payment.new
p.authorization_token = 'hola'
p.save!
p.order_id = 1
p.save!
actual
authorizer.errors
authorizer.errors['message']
authorizer.errors['message']['code']
authorizer.errors['message'].first['code']
authorizer.errors['message'].include?({"code"=>"81531",)
"attribute"=>"amount",
exit
result
result.transaction
result.errors
exit
step
n
continue
errors
n
errors
n
exit
continue
errors
errors.select { |code, _| code == '81531' }
errors.select { |code, _| code == '81531' }.empty?
exit
errors
authorizer.errors
authorizer.successful
authorizer.successful?
exit
authorizer.errors
self.braintree_sale_results
self.send(:braintree_sale_results)
authorizer.send(:braintree_sale_results)
authorizer
authorizer.transaction
braintree_sale_results
braintree_sale_result
braintree_sale_result.errors
n
errors
errors.merge!(payment: flash_error_message)
n
adapter.errors
step
n
adapter.errors.to_json
n
step
n
exit
Bellroy.secrets
Bellroy.secrets.braintree
Bellroy.secrets['braintree']
Bellroy.secrets['braintree']['paypal_express']
Bellroy.secrets['braintree']['paypal_express'].with_indiferent_access
Bellroy.secrets['braintree']['paypal_express'].with_indifferent_access
exit
Bellroy
Bellroy.secrets
Bellroy.secrets.braintree
Bellroy.secrets.class
Bellroy.secrets.merge({a:2})
Bellroy.secrets.merge({a:2}).class
exit
Bellroy
Bellroy.secrets
Bellroy.secrets.braintree
Bellroy.secrets.braintree.paypal_express
Bellroy.secrets.braintree['braintree']
Bellroy.secrets.braintree['paypal_express']
Bellroy.secrets.braintree[:paypal_express]
Bellroy.secrets.braintree.slice[:paypal_express]
Bellroy.secrets.braintree.slice(:paypal_express)
Bellroy.secrets.braintree.slice('paypal_express')
Bellroy.secrets.braintree['paypal_express'].with_indifferent_access
SaasuClient.configuration
SaasuClient.configuration.redis
exit
exit!
SaasuClient.configuration
exit!
SaasuClient.configuration
exit
SaasuClient.configuration
exit!
SaasuClient.configuration
exit!
SaasuClient.configuration
exit!
redis.exists(ACCESS_TOKEN_REDIS_KEY)
n
continue
redis.exists(ACCESS_TOKEN_REDIS_KEY)
step
n
continue
redis.exists(ACCESS_TOKEN_REDIS_KEY)
n
exit
exit!
redis.exists(ACCESS_TOKEN_REDIS_KEY)
continue
redis.exists(ACCESS_TOKEN_REDIS_KEY)
continue
redis.exists(ACCESS_TOKEN_REDIS_KEY)
request_method
endpoint
caler
caller
exit
exit!
token_expires_in_sec
token_expires_in_sec/60
token_expires_in_sec
continue
caller
continue
token_expires_in_sec
token_expires_in_sec/3600
continue
redis.get(ACCESS_TOKEN_REDIS_KEY)
exit!
redis.get(ACCESS_TOKEN_REDIS_KEY)
Redis.new.get(ACCESS_TOKEN_REDIS_KEY)
redis.set('pais', 'Peru')
redis.get('pais')
continue
Redis.new.get(ACCESS_TOKEN_REDIS_KEY)
redis.set('pais', 'Peru')
redis.get('pais')
continue
Redis.new.get(ACCESS_TOKEN_REDIS_KEY)
redis.get('pais')
continue
Redis.new.get(ACCESS_TOKEN_REDIS_KEY)
redis.get('pais')
exit
exit!
exit
exit!
resdis
continue
redis.exists(ACCESS_TOKEN_REDIS_KEY)
exit
n
redis.get(ACCESS_TOKEN_REDIS_KEY)
exit
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('seld', 'seld')
self
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('context', 'context')
self
line_items_adapter
line_items_adapters
line_item_adapters
exit
continue
context
context.respond_to?(:line_item_adapters)
context.line_item_adapters
context.line_item_adapters.class
context.line_item_adapters
context.line_item_adapters.quantity
exit
line_item_adapters
line_item_adapters.first
line_item_adapters.first.hast_tag?('medium')
line_item_adapters.first.has_tag?('medium')
exit
context
context.is_a?(AbstractUserMetadataAdapter)
order_adapter
exit
context
exit
order_adapter
order_adapter.present?
line_item_adapter
puts order_adapter
arg
args
exit!
args
arg
exit!
klass::VALID_ARGUMENTS.
klass
klass::VALID_ARGUMENTS
args
exit!
self
self.context
exit
expression
next
expression
n
expression
n
continue
expression
continue
expression
continue
expression
context
tree = ExpressionParser.new.parse(expression)
step
n
transform
transforme.eval
transform.eval
transform.send(:eval)
transform.class
exit
args
c
args
c
args
c
args
args.first
args[1]
args[1].class
exit
context
arguments
function_name
self
continue
self
sequence(:tagarglist)
subtree(:tagarglist)
subtree(:tagarglist)[:sequence]
tagarlist
tagarglist
subtree(tagarglist)
subtree(tagarglist)[:sequence]
subtree(tagarglist)
subtree(tagarglist)[:tagarg]
exit
args
args.flatten
[1].flatten
exit
arglist
arglist[:sequence]
arglist[:sequence].map(&:to_s)
exit
exit!
tagarglist
tagarglist.to_s
[tagarglist]
[tagarglist].flatten
[tagarglist].flatten.map(:to_s)
[tagarglist].flatten.map(:&to_s)
[tagarglist].flatten.map(&:to_s)
exit
exit!
tagarglist
c
tagroot
c
tagroot
c
tagroot
c
tagroot
c
tagroot
c
tagroot
c
tagroot
tagarglist
*[tagarglist].flatten.map(&:to_s)
tagarglist
tagarglist.sequence
c
tagarglist
tagarglist.sequence
exit!
transformed_arglist
n
exit!
tagarglist.sequence
tagarglist.sequence.map(&:to_s)
*tagarglist.sequence.map(&:to_s)
*(tagarglist.sequence.map(&:to_s))
context
IntegerExpressionEvaluator.new(context, cart_extra_expression).result.try(:*, 100)
next
n
shipping_costs.extra_in_cents
shipping_costs.line_items_total_in_cents
exit
line_items.values
line_items.values.sum
line_items.values.flatten.sum
line_items.values
line_items.values.empty?
line_items.values.collapseempty?
line_items.values.collapse.empty?
line_items.values.compact.empty?
exit!
tree
transform
transform.eval
c
tree
c
tree
c
tree
transform
exit
c
tree
transform
exit!
not_operator
not_argument
self
value
exit
tree
transform
c
tree
transform
c
tree
transform
c
self
transform.eval
c
tree
n
tree
ExpressionTransform.new.apply(tree, context: context)
exit
c
tree
transform
transform.eval
exit
literal_boolean
not_argument
literal_boolean
exit
value
value == 'true'
value.to_s
value.class
exit
MatchingShippingRule.new(order_adapter, user_metadata_adapter)
exit
filter
BooleanExpressionEvaluator.new(context, filter).result
c
BooleanExpressionEvaluator.new(context, filter).result
filter
c
filter
BooleanExpressionEvaluator.new(context, filter).result
step
n
super
step
n
tree
n
transform
tree
exit
tree
transform
transform.class
c
transform.class
n
transform.class
c
transform.class
c
transform.class
tree
transform.eval
tree
transfomr
transform
tree
transform
exit!
self
not_operand
sequence
subtree
subtree.eval
exit!
arg
exit
function_class
function_class.is_a?(CustomFunctionWithArguments)
function_class < CustomFunctionWithArguments
exit
exit!
[args].flatten
self.class::VALID_ARGUMENTS.zip([args].flatten)
exit
self.class::VALID_ARGUMENTS.first
args
exit
expression_transform
expression_transform.class
exit
nodes
nodes.first
nodes.second
nodes
nodes.methods?
nodes.methods
nodes.inquery
nodes.to_query
nodes.methods
nodes.to_query
nodes
nodes.methods
nodes.entries
nodes.methods
git st
nodes.eval
transform
expression_transform
expression_transform.val
expression_transform.eval
nodes
expression_transform.second
expression_transform
expression_transform.sequence
expression_transform.sequence.first
expression_transform.sequence.second
expression_transform.sequence.second.second
expression_transform.sequence.second.right
expression_transform.sequence
expression_transform.sequence.flatten
expression = 'FREE + NO_SHIPPING_OFFERED'
ExpressionParser.new.parse(expression)
expression_transform.sequence
expression_transform.recurse_hash
expression_transform.recurse_hash(expression_transform)
expression_transform.rules
expression_transform.send(:rules)
expression_transform
ExpressionParser.new.parse(expression)
parser = _
ExpressionTransform.new.apply(parser, context: nil)
ExpressionTransform.new.apply(parser, context: nil).parselets
ExpressionTransform.new.apply(parser, context: nil).parslets
ExpressionTransform.new.apply(parser, context: nil).to_s
ExpressionTransform.new.apply(parser, context: nil).to_s_inner
ExpressionTransform.new.apply(parser, context: nil).flatten_repetition
ExpressionTransform.new.apply(parser, context: nil).flatten
ExpressionTransform.new.apply(parser, context: nil).send(:flatten)
ExpressionTransform.new.apply(parser, context: nil).flatten_sequence
ExpressionTransform.new.apply(parser, context: nil)
ExpressionTransform.new.apply(parser, context: nil).sequence
ExpressionTransform.new.apply(parser, context: nil).sequence.flatten
ExpressionTransform.new.apply(parser, context: nil).sequence.flatten_repetitive
ExpressionTransform.new.apply(parser, context: nil).sequence.classs
ExpressionTransform.new.apply(parser, context: nil).sequence.class
exit
nodes
nodes.class
expression = 'FREE + NO_SHIPPING_OFFERED'
ExpressionParser.new.parse(expression)
ExpressionTransform.new.apply(parser, context: nil).sequence.class
ExpressionTransform.new.apply(parser, context: nil).sequence
ExpressionTransform.new.apply(parser, context: nil)
expression = 'FREE + NO_SHIPPING_OFFERED'
ExpressionParser.new.parse(expression)
parser = ExpressionParser.new.parse(expression)
ExpressionTransform.new.apply(parser, context: nil)
ExpressionTransform.new.apply(parser, context: nil).to_seq
ExpressionTransform.new.apply(parser, context: nil).to_seq.class
ExpressionTransform.new.apply(parser, context: nil).to_seq.flatten
ExpressionTransform.new.apply(parser, context: nil).to_seq.flatten_repetitice
ExpressionTransform.new.apply(parser, context: nil).to_seq.flatten_repetitive
ExpressionTransform.new.apply(parser, context: nil)
ExpressionTransform.new.apply(parser, context: nil).inject([]) { |accum, operation| operation.try(:function_name) }
ExpressionTransform.new.apply(parser, context: nil).inject([]) { |accum, operation| puts operation }
exit
nodes
nodes.first
nodes.first.last
nodes.last
nodes.size
nodes.first
nodes.first.sequence
nodes.first.sequence.last
nodes.first.sequence
nodes.first.sequence.right
nodes.first.sequence.first
nodes.first.sequence.second
nodes.first.sequence.second.right
nodes.first.sequence.second
nodes.first.sequence.second.class
nodes.first.sequence
nodes.first.sequence.right
nodes.first.sequence
nodes.first.sequence.first
nodes.first.sequence
nodes.first.sequence.first
nodesd
nodes
expression_transform
expression_transform.sequence
expression_transform
expression_transform.class
expression_transform.sequence.class
expression_transform.sequence.first
expression_transform.first
expression_transform.first == expression_transform.sequence.first
expression_transform.first.class == expression_transform.sequence.first.class
expression_transform.first.class
expression_transform.sequence.first.class
exit
nodes
nodes.dictionary_entry
exit
nodes.
;
nodes
nodes.dictionary_entry
nodes.dictionary_entry.class
nodes
nodes.context
nodes.arguments
nodes.klass
nodes.dictionary_entry
nodes.dictionary_entry.klass
exit
value
ExpressionEvaluator.new(nil, value)
shipping_rule
shipping_rule.be_valid
shipping_rule.be_valid?
shipping_rule.valid?
record
Kaos::Shipping::ExpressionEvaluator.new(nil, value).transform
c
n
c
record
n
c
record
c
record
c
record
c
record
c
record
c
record
c
record
c
record
c
record
c
record
c
record
c
record
c
record
c
record
c
record
c
record
c
record
c
record
attrivute
attribute
value
Kaos::Shipping::ExpressionEvaluator.new(nil, value)
Kaos::Shipping::ExpressionEvaluator.new(nil, value).transform
c
tree
n
continue
ExpressionTransform.new.apply(tree, context: context)
ExpressionTransform.new.apply(tree, context: context)exit
exit!
ExpressionTransform.new.apply(tree, context: context)
expression
tree
ExpressionTransform.new.apply(tree, context: context)
ExpressionTransform.new.apply(tree, context: nil)
ExpressionTransform.new.apply(tree, context: 'hola')
exit
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('line_items', '[1] pry(#<Kaos::Shipping::ShippingCosts>)>line_items')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('line_items.', '[1] pry(#<Kaos::Shipping::ShippingCosts>)>line_items.')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('line', '[1] pry(#<Kaos::Shipping::ShippingCosts>)>line_items.')
line_items.values
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('line_items.values.', 'line_items.values.')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('line', 'line_items.values.')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('line_items.values.', 'line_items.values.')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('line', 'line_items.values.')
line_items.values
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('line', '[1] pry(#<Kaos::Shipping::ShippingCosts>)> line')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('line_', '[1] pry(#<Kaos::Shipping::ShippingCosts>)> line_')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('line__', '[1] pry(#<Kaos::Shipping::ShippingCosts>)> line__')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('line', '[1] pry(#<Kaos::Shipping::ShippingCosts>)> line__')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('line_', 'line_')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('line_i', 'line_i')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('line_it', 'line_it')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('line_ite', 'line_ite')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('line_item', 'line_item')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('line_items', 'line_items')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('line_itemsi', 'line_itemsi')
proc { |expr, line|  require 'ostruct';  old_wp = defined?(Bond) && Bond.started? && Bond.agent.weapon;  begin    Bond.agent.instance_variable_set('@weapon',      OpenStruct.new(:line_buffer => line)) if old_wp;    if defined?(_pry_.complete) then      puts _pry_.complete(expr)    else      completer = if defined?(_pry_) then        Pry.config.completer.build_completion_proc(binding, _pry_)      elsif old_wp then        Bond.agent      elsif defined?(IRB::InputCompletor::CompletionProc) then        IRB::InputCompletor::CompletionProc      end and puts completer.call(expr).compact    end  ensure    Bond.agent.instance_variable_set('@weapon', old_wp) if old_wp   end }.call('line', 'line_itemsi')
line_itemsitem
line_items
line_items.values.sum
line_items.values
line_items
line_items.values
line_items.values.sum
continue
Kaos::Shipping::ExpressionEvaluator.new(nil, value)
Kaos::Shipping::ExpressionEvaluator.new(nil, value).transform
c
Kaos::Shipping::ExpressionEvaluator.new(nil, value).transform
c
Kaos::Shipping::ExpressionEvaluator.new(nil, value).transform
c
Kaos::Shipping::ExpressionEvaluator.new(nil, value
)
e = _
_.transform
c
Kaos::Shipping::ExpressionEvaluator.new(nil, value).transform
step
n
tree
n
tree
ExpressionTransform.new.apply(tree, context: context)
n
transform
=> #<struct Kaos::Shipping::ExpressionTransform::Function
 dictionary_entry=
  #<Kaos::Shipping::FunctionsDictionaryEntry:0x0000000c1509a8
   @function_name="free",
   @klass=Kaos::Shipping::Functions::FreeShipping,
   @type_class=Kaos::Shipping::ExpressionTransform::Int>,
 arguments=nil,
 context=nil>.class
transform.class
n
transform
n
errors
c
value
c
value
c
record.errors
c
record.errors
c
record.errors
exit
record.errors
record
attribute
value
e
Kaos::Shipping::ExpressionEvaluator.new(nil, value).transform
Kaos::Shipping::ExpressionEvaluator.new(nil, value)
Kaos::Shipping::ExpressionEvaluator.new(nil, value).transform
value
Kaos::Shipping::ExpressionEvaluator.new(nil, value).transform
step
n
tree
ExpressionTransform.new.apply(tree, context: context)
 Kaos::Shipping::ExpressionEvaluator.new(nil, value).transform
 Kaos::Shipping::ExpressionEvaluator.new(nil, value).transform.eval
 Kaos::Shipping::ExpressionEvaluator.new(nil, value).transform
exit
options
n
klass
klass.new(Kaos::Shipping::Context.null_object, value)
klass.new(Kaos::Shipping::Context.null_object, value).value
klass.new(Kaos::Shipping::Context.null_object, value).result
c
klass.new(Kaos::Shipping::Context.null_object, value).result
c
klass.new(Kaos::Shipping::Context.null_object, value).result
record.errors
c
attribute
e
arg
n
exit
order_adapter.has_tag?(arg)
step
n
exit
order_adapter
order_adapter.has_tag?
unless defined? Robe;  $:.unshift '/home/sadhu/.emacs.d/elpa/robe-20170611.1755/lib';  require 'robe';end;Robe.start
@context
exit
unless defined? Robe;  $:.unshift '/home/sadhu/.emacs.d/elpa/robe-20170611.1755/lib';  require 'robe';end;Robe.start
'{"first":"hola","second":"chau"}'
"{"first":"hola","second":"chau"}"
JSON.parse '{"first":"hola","second":"chau"}'
JSON.parse '["hola", "chau"]'
exit
unless defined? Robe;  $:.unshift '/home/sadhu/.emacs.d/elpa/robe-20170611.1755/lib';  require 'robe';end;Robe.start
eval <<'--inf-ruby-5f244ce6c715c93-22950-26871-85063--', (defined?(IRB) && IRB.conf[:MAIN_CONTEXT] && IRB.conf[:MAIN_CONTEXT].workspace.binding) || (defined?(Pry) && Pry.toplevel_binding), "/home/sadhu/Projects/Bellroy/bellroy/app/presenters/liquid/content_block_variables.rb", 141
    def customization
      user_data_hash[:customization]
    end
--inf-ruby-5f244ce6c715c93-22950-26871-85063--
cookies
request
request.cookie_jar
exit
unless defined? Robe;  $:.unshift '/home/sadhu/.emacs.d/elpa/robe-20170611.1755/lib';  require 'robe';end;Robe.start
concerns
concerns.first
cookies_to_check
user_cookies
unless defined? Robe;  $:.unshift '/home/sadhu/.emacs.d/elpa/robe-20170611.1755/lib';  require 'robe';end;Robe.start
session_meta_data
session_meta_data.user_data_hash
session_meta_data
session_meta_data.user_data_hash
n
exit
n
s
n
exit
user_data_hash
n
ar_order
ar_order.assign_attributes(order_attributes)
order_attributes
order_attributes.to_h
order_attributes.drop('cookies')
order_attributes['cookies']
order_attributes['cookies'] = nil
order_attributes
wxitr
exit
Order
order = Order.first
order.cache_key
order
order.shop_order
order.email
order.shop_order
order.email
order.customer_email
order
order.customer_email
order
shop_order
order
order.shop_order
order.shop_order.email
order.shop_order.customer_email
order.shop_order.email
order.email
order.customer_email
exit
n
params.keys.include?
params.keys.include? 'kaos_product_config_offering'
params.keys
n
resource_class
n
exception
n
exception
c
n
step
n
JSON.parse(params[:resources])
c
params.keys
params.keys << 'kaos_product_config_offering'
n
params.keys.include? 'kaos_product_config_offering'
params.keys
c
n
params.keys = params.keys + ['kaos_product_config_offering']
c
n
step
n
step
n
exception
exit
n
params
params.keys
JSON.parse(params[:resources])
::Kaos::ProductConfig::Currency.all
c
I18n::MissingTranslation
I18n::MissingTranslation < I18n::MissingTranslationData
I18n::MissingTranslationData < I18n::MissingTranslation
I18n::MissingTranslationData
I18n::MissingTranslation < I18n::MissingTranslationData
I18n::MissingTranslationData.new
I18n::MissingTranslationData.new(nil, nil)
I18n::MissingTranslationData.new(nil, nil).is_a?(I18n::MissingTranslation)
exit
exception
exception.class
locale
key
options
exception
exception.message
exception.url
pp exception
exception.methods?
exception.instance_methods?
exception.instance_methods
exception.methods
exception.backtrace
exception.backtrace_locations
exception.as_json
self
self.methods
@app
env
Raven::Rack
request.env
Raven::Rails
Raven::Rails.request
data
c
exception
request
n
s
request
locale
key
options
s
request
n
request
n
s
n
MissingTranslation < Exception
n
str
n
exit
ENV
Rails.env
env
ENV
app
context
self
self.context
self.methods
self.instance_variables
self.instance_methods
self.inspect
self
Raven::Context
Raven.rack_context
Raven::Context.methods
Raven::Context.runtime_context
Raven::Context.context
Raven::Context.methods
Raven::Context.to_json
c
Raven::Context.to_json
Raven::Context.env
Raven::Context.
Raven::Context.methods
Raven::Context.new
Raven::Configuration.new
Raven.capture
instance = Raven::Instance.new(Raven::Context.new, Raven::Configuration.new)
Raven::Processor::PostData
Raven::Processor::PostData.new
Raven::Processor::PostData::Cookies
Raven
Raven.methods
Raven.client
Raven.methods
Raven.capture_type
Raven.rack_context
Raven.user_context
c
Raven.rack_context
show-source Raven.rack_context
show-source Raven.rack_context -l
self
module Raven
  class Event
    def self.from_exception(exc, options = {}, &block)
      binding.pry
      exception_context = if exc.instance_variable_defined?(:@__raven_context)
        exc.instance_variable_get(:@__raven_context)
      elsif exc.respond_to?(:raven_context)
        exc.raven_context
      else
        {}
      end
      options = Raven::Utils::DeepMergeHash.deep_merge(exception_context, options)
      configuration = options[:configuration] || Raven.configuration
      return unless configuration.exception_class_allowed?(exc)
      new(options) do |evt|
        evt.message = "#{exc.class}: #{exc.message}"
        evt.add_exception_interface(exc)
        yield evt if block
      end
    end
  end
end
c
exception
exception.to_exception
exception.to_exception.as_json
n
s
n
s
c
n
s
n
Raven::Instance.new
s
n
s
n
s
n
configuration.capture_allowed?(obj)
obj
configuration
s
n
self
n
configuration.error_message
self.configuration.error_message
configuration.error_messages
exit
n
s
n
message_or_exc
n
context
n
c
ENV['RACK_ENV']
n
s
self
Raven
Raven.instance
n
Raven.instance.context
Raven.instance.context.rack_env
Raven.instance.context.request
Raven::Context.current
Raven::Context.current['REQUEST_PATH']
Raven::Context.current.rack_env['REQUEST_PATH']
Raven::Context.current
Raven::Context.current.rack_env['REQUEST_PATH']
Raven::Context.current.rack_env.try([], 'REQUEST_PATH')
Raven::Context.current.rack_env.try([], 'REQUEST_PATH')
Raven::Context.current.rack_env.try(:[], 'REQUEST_PATH')
Raven::Context.current.rack_env.try(:[], 'REQUEST_PATH')
exit
exit
SAASU_CONFIG
SAASU_CONFIG.files
SAASU_CONFIG.exclude('files')
SAASU_CONFIG.except('files')
SAASU_CONFIG.except('files').merge(SAASU_CONFIG['files'].except('pty_ltd'))
n
files_except_pty_ltd
SAASU_CONFIG.except('files').merge(files_except_pty_ltd)
Siegfried::Config.saasu[:files][:trading_eventual][:uid]
SAASU_CONFIG
SAASU_CONFIG[:files][:trading_eventual][:uid]
SAASU_CONFIG.except('files').merge(files_except_pty_ltd).with_indiferent_access
SAASU_CONFIG.except('files').merge(files_except_pty_ltd)
SAASU_CONFIG.except('files').merge({files: files_except_pty_ltd}).with_indiferent_access
SAASU_CONFIG.except('files').merge({files: files_except_pty_ltd})
unless defined? Robe;  $:.unshift '/home/sadhu/.emacs.d/elpa/robe-20170611.1755/lib';  require 'robe';end;Robe.start
exit
unless defined? Robe;  $:.unshift '/home/sadhu/.emacs.d/elpa/robe-20170611.1755/lib';  require 'robe';end;Robe.start
logger
debug
Rails.logger.debug 'hola'
exit
